require('dotenv').config();
const express = require('express');
const { MongoClient, ServerApiVersion } = require('mongodb');
const { LineClient } = require('@line/bot-sdk');
const OpenAI = require("openai");
const cron = require('node-cron'); // スケジュールタスク用

const app = express();
const lineConfig = {
    channelAccessToken: process.env.LINE_CHANNEL_ACCESS_TOKEN,
    channelSecret: process.env.LINE_CHANNEL_SECRET,
};
const client = new LineClient(lineConfig);

const openai = new OpenAI({
    apiKey: process.env.OPENAI_API_KEY,
});

const uri = process.env.MONGODB_URI;
const OWNER_USER_ID = process.env.OWNER_USER_ID; // 管理者ユーザーID

let db; // MongoDBクライアントを保持する変数

// MongoDB接続関数
async function connectToMongoDB() {
    if (db) {
        return db; // 既に接続済みであれば既存の接続を返す
    }
    const client = new MongoClient(uri, {
        serverApi: {
            version: ServerApiVersion.v1,
            strict: true,
            deprecationErrors: true,
        }
    });

    try {
        await client.connect();
        db = client.db("Cluster0"); // データベース名を指定
        console.log("✅  MongoDBに接続しました！");

        // 月次リセットをスケジュール
        cron.schedule('0 0 1 * *', async () => { // 毎月1日の0時0分に実行
            console.log('--- 月次メッセージカウントリセット処理を開始します ---');
            const usersCollection = db.collection("users");
            try {
                const result = await usersCollection.updateMany(
                    {},
                    { $set: { monthlyMessageCount: 0 } }
                );
                console.log(`リセットされたユーザー数: ${result.modifiedCount}`);

                // 全ユーザーの monthlyMessageCount をリセットした旨をログに記録
                await db.collection("messages").insertOne({
                    userId: 'system',
                    message: '月次メッセージカウントリセット',
                    replyText: '全ユーザーの月次メッセージカウントがリセットされました。',
                    respondedBy: 'システム',
                    timestamp: new Date(),
                    logType: 'monthly_reset'
                });
            } catch (error) {
                console.error('月次メッセージカウントリセット中にエラーが発生しました:', error);
            }
            console.log('--- 月次メッセージカウントリセット処理を完了しました ---');
        }, {
            timezone: "Asia/Tokyo"
        }); // タイムゾーンを日本に設定
        console.log("✅ 定期ジョブがスケジュールされました。");

        return db;
    } catch (error) {
        console.error("MongoDB接続エラー:", error);
        db = null; // 接続失敗時はdbをnullにする
        return null;
    }
}

// ユーザーの表示名を取得する関数
async function getUserDisplayName(userId) {
    try {
        const profile = await client.getProfile(userId);
        return profile.displayName;
    } catch (error) {
        console.error(`ユーザー ${userId} の表示名取得エラー:`, error.message);
        return "名無しさん"; // 取得できない場合はデフォルト名を返す
    }
}

// 不適切な言葉のリスト
const inappropriateWords = [
    '死ね', '殺す', 'きもい', 'うざい', 'だるい', '消えろ', 'カス', 'クズ', 'ブス', 'バカ', 'アホ', 'うんこ', 'ちんちん', 'まんこ', 'セックス', '氏ね', 'きも', 'ウザい', 'ダルい', '殺すぞ', '殺し', '殺され', '殺し合い', 'キチガイ', 'ガイジ', '糞', 'クソ', '変態', 'レイプ', '強姦', '暴力', '暴行', '殴る', '蹴る', '呪う', '呪い', '穢れ', '穢い', '腐る', '腐れ', '腐った', 'ゲロ', '吐く', '死にたい', '殺して', '殺してほしい', '消えたい', '自殺', '自死', '首吊り', '飛び降り', '飛び込み', 'OD', 'オーバードーズ', 'リストカット', 'リスカ', 'メンヘラ', '基地外', 'グロ', '閲覧注意', '胸糞', '陰毛', 'アナル', 'オナニー', '手コキ', '潮吹き', '痴女', '風俗', 'ソープ', 'デリヘル', '売春', '買春', 'AV', 'アダルトビデオ', 'ポルノ', '童貞', '処女', '売女', '淫乱', '売春婦', 'ホモ', 'レズ', 'ノンケ', '障碍者', '障害者', '池沼', 'チョン', '土人', 'クロンボ', '乞食', 'ドキュン', 'ヤンキー', 'チンピラ', '下劣', '卑しい', '汚い', '糞尿', '大便', '小便', '屁', 'ゲップ', '唾', '痰', '汚物', '蛆虫', '寄生虫', 'ゴキブリ', 'ネズミ', '害虫', 'ウイルス', '病気', '疫病', '疫病神', '疫病退散', '疫病退治', '病死', '病気死', '病魔', '病魔退散', '病魔退治', '癌', 'ガン', '悪性新生物', '腫瘍', '腫瘤', '結節', 'ポリープ', '嚢胞', '嚢腫', '膿', '化膿', '炎症', '壊死', '壊疽', '細胞死', '細胞破壊', '細胞変性', '細胞異型', '異型細胞', '癌細胞', '悪性細胞', '悪性腫瘍', '悪性新生物', '転移', '再発', '浸潤', '分化度', '悪性度', '進行度', 'ステージ', '余命', '末期', '闘病', '抗がん剤', '放射線治療', '手術', '切除', '摘出', '移植', '人工臓器', '人工呼吸器', '人工透析', '延命治療', '緩和ケア', '安楽死', '尊厳死', 'リビングウィル', '尊厳死協会', '日本尊厳死協会', '死の権利', '死を選ぶ権利', '自己決定権', '自己決定', 'インフォームドコンセント', 'セカンドオピニオン', 'ターミナルケア', '終末期医療', '終末期ケア', 'グリーフケア', 'エンゼルケア', '看取り', '臨終', '葬儀', '葬式', '告別式', '火葬', '土葬', '埋葬', '永代供養', '納骨', '遺骨', '遺灰', '遺髪', '遺品', '遺書', '遺言', '形見', '思い出', '供養', '追悼', '冥福', '合掌', '南無阿弥陀仏', '南無妙法蓮華経', 'アーメン', 'ハレルヤ', '阿弥陀仏', '地蔵菩薩', '観音菩薩', '不動明王', '大日如来', '釈迦如来', '薬師如来', '如来', '菩薩', '明王', '天', '神', '仏', '精霊', '魂', '霊魂', '幽霊', '亡霊', '妖怪', 'お化け', '悪魔', 'サタン', 'ルシファー', 'ベルゼブブ', 'アザゼル', 'アスモデウス', 'ベリアル', 'レヴィアタン', 'バフォメット', 'リリス', 'モロク', 'パイモン', 'アモン', 'アスタロト', 'アバドン', 'アムドゥシアス', 'アンドラス', 'アンドロマリウス', 'ゼパル', 'デカラビア', 'フォカロル', 'ブネ', 'フルカス', 'ベリト', 'マルコシアス', 'ラウム', 'グレモリー', 'ウァレフォル', 'ガープ', 'アガレス', 'ヴァッサゴ', 'フルフル', 'アイム', 'シャックス', 'オリアス', 'オセ', 'クロケル', 'シトリー', 'ゼガン', 'ディンギン', 'パーセル', 'パイモン', 'バルバトス', 'ベレト', 'フラウロス', 'プロケル', 'ボティス', 'マモン', 'ムルムル', 'ロノウェ', 'ワシントン', 'フリーメイソン', 'イルミナティ', '秘密結社', '陰謀論', 'Qアノン', 'アノン', '世界政府', '新世界秩序', 'NWO', 'ワンワールド', 'グレートリセット', 'COVID-19は嘘', 'ワクチンは毒', 'マイクロチップ', '5Gは危険', 'ケムトレイル', 'HAARP', '人工地震', '人工津波', '人工台風', '気象兵器', '地震兵器', '津波兵器', '台風兵器', '電磁波兵器', '指向性エネルギー兵器', 'DEW', 'UFO', '宇宙人', '地球空洞説', 'フラットアース', '偽ユダヤ', 'ホロコーストは嘘', '911自作自演', '311人工地震', '地震テロ', '津波テロ', 'テロリスト', 'テロリズム', '過激派', '過激思想', 'カルト', '統一教会', '創価学会', 'オウム真理教', '幸福の科学', 'エホバの証人', 'ものみの塔', 'モルモン教', 'キリスト教原理主義', 'イスラム原理主義', '原理主義', '異端', '異教徒', '異民族', '異人種', '外国人排斥', 'ヘイトスピーチ', '差別', '人種差別', '民族差別', '宗教差別', '性差別', '年齢差別', '出身地差別', '学歴差別', '職業差別', '身分差別', '階級差別', '貧富の差', '格差社会', '弱者男性', '弱者女性', '強者男性', '強者女性', '男女平等は嘘', 'フェミニストは敵', 'アンチフェミ', 'ミソジニー', 'ミサンドリー', 'ルッキズム', 'デブ', 'ハゲ', 'チビ', 'ブサイク', '不細工', '障害者差別', '精神病', '発達障害', 'ADHD', 'ASD', 'アスペルガー', '自閉症', 'ダウン症', 'うつ病', '統合失調症', '双極性障害', 'パニック障害', '不安障害', '境界性パーソナリティ障害', '精神疾患', '精神障害', '知的障害', '身体障害', '難病', '奇病', '不治の病', '感染症', '伝染病', 'エイズ', 'HIV', '性病', '梅毒', '淋病', 'クラミジア', 'ヘルペス', '尖圭コンジローマ', '肝炎', 'B型肝炎', 'C型肝炎', '結核', 'ハンセン病', 'ポリオ', '天然痘', '麻疹', '風疹', 'おたふく風邪', '水疱瘡', 'インフルエンザ', 'コロナウイルス', 'COVID-19', 'SARS', 'MERS', '新型インフルエンザ', '鳥インフルエンザ', '豚インフルエンザ', '狂犬病', '破傷風', '日本脳炎', 'デング熱', 'マラリア', 'ジカ熱', 'エボラ出血熱', '出血熱', '炭疽菌', 'サリン', 'VXガス', '毒ガス', '化学兵器', '生物兵器', '核兵器', '原爆', '水爆', '放射能', '被曝', '被爆', '原発事故', '福島原発', 'チェルノブイリ', 'スリーマイル', '核実験', '核廃棄物', '汚染水', '放射能汚染', '放射性物質', '汚染', '公害', '環境汚染', '地球温暖化は嘘', 'SDGsは嘘', '脱炭素は嘘', 'エセ科学', '似非科学', 'ニセ科学', 'トンデモ科学', '超能力', 'UFO', '宇宙人', '地球空洞説', 'フラットアース', 'フリーエネルギー', '永久機関', 'タイムマシン', '予言', '占い', '呪術', '黒魔術', '白魔術', '悪霊', '憑依', '除霊', ' exorcism', '降霊術', '心霊現象', '幽霊', '怪談', '都市伝説', 'UMA', '未確認生物', 'ネッシー', 'ビッグフット', 'ツチノコ', '人魚', '吸血鬼', '狼男', 'ゾンビ', 'フランケンシュタイン', 'ミイラ', '魔女', '魔法使い', '魔術師', '妖精', '天使', '悪魔', '神', '仏', '精霊', '魂', '霊魂', '幽霊', '亡霊', '妖怪', 'お化け', '霊界', '天国', '地獄', '冥界', '黄泉の国', 'あの世', 'この世', '現世', '来世', '前世', '輪廻転生', '転生', '生まれ変わり', '悟り', '解脱', '涅槃', '成仏', '供養', '追悼', '冥福', '合掌', '南無阿弥陀仏', '南無妙法蓮華経', 'アーメン', 'ハレルヤ', '阿弥陀仏', '地蔵菩薩', '観音菩薩', '不動明王', '大日如来', '釈迦如来', '薬師如来', '如来', '菩薩', '明王', '天', '神', '仏', '精霊', '魂', '霊魂', '幽霊', '亡霊', '妖怪', 'お化け', '悪魔', 'サタン', 'ルシファー', 'ベルゼブブ', 'アザゼル', 'アスモデウス', 'ベリアル', 'レヴィアタン', 'バフォメット', 'リリス', 'モロク', 'パイモン', 'アモン', 'アスタロト', 'アバドン', 'アムドゥシアス', 'アンドラス', 'アンドロマリウス', 'ゼパル', 'デカラビア', 'フォカロル', 'ブネ', 'フルカス', 'ベリト', 'マルコシアス', 'ラウム', 'グレモリー', 'ウァレフォル', 'ガープ', 'アガレス', 'ヴァッサゴ', 'フルフル', 'アイム', 'シャックス', 'オリアス', 'オセ', 'クロケル', 'シトリー', 'ゼガン', 'ディンギン', 'パーセル', 'パイモン', 'バルバトス', 'ベレト', 'フラウロス', 'プロケル', 'ボティス', 'マモン', 'ムルムル', 'ロノウェ', 'ワシントン', 'フリーメイソン', 'イルミナティ', '秘密結社', '陰謀論', 'Qアノン', 'アノン', '世界政府', '新世界秩序', 'NWO', 'ワンワールド', 'グレートリセット', 'COVID-19は嘘', 'ワクチンは毒', 'マイクロチップ', '5Gは危険', 'ケムトレイル', 'HAARP', '人工地震', '人工津波', '人工台風', '気象兵器', '地震兵器', '津波兵器', '台風兵器', '電磁波兵器', '指向性エネルギー兵器', 'DEW', 'UFO', '宇宙人', '地球空洞説', 'フラットアース', '偽ユダヤ', 'ホロコーストは嘘', '911自作自演', '311人工地震', '地震テロ', '津波テロ', 'テロリスト', 'テロリズム', '過激派', '過激思想', 'カルト', '統一教会', '創価学会', 'オウム真理教', '幸福の科学', 'エホバの証人', 'ものみの塔', 'モルモン教', 'キリスト教原理主義', 'イスラム原理主義', '原理主義', '異端', '異教徒', '異民族', '異人種', '外国人排斥', 'ヘイトスピーチ', '差別', '人種差別', '民族差別', '宗教差別', '性差別', '年齢差別', '出身地差別', '学歴差別', '職業差別', '身分差別', '階級差別', '貧富の差', '格差社会', '弱者男性', '弱者女性', '強者男性', '強者女性', '男女平等は嘘', 'フェミニストは敵', 'アンチフェミ', 'ミソジニー', 'ミサンドリー', 'ルッキズム', 'デブ', 'ハゲ', 'チビ', 'ブサイク', '不細工', '障害者差別', '精神病', '発達障害', 'ADHD', 'ASD', 'アスペルガー', '自閉症', 'ダウン症', 'うつ病', '統合失調症', '双極性障害', 'パニック障害', '不安障害', '境界性パーソナリティ障害', '精神疾患', '精神障害', '知的障害', '身体障害', '難病', '奇病', '不治の病', '感染症', '伝染病', 'エイズ', 'HIV', '性病', '梅毒', '淋病', 'クラミジア', 'ヘルペス', '尖圭コンジローマ', '肝炎', 'B型肝炎', 'C型肝炎', '結核', 'ハンセン病', 'ポリオ', '天然痘', '麻疹', '風疹', 'おたふく風邪', '水疱瘡', 'インフルエンザ', 'コロナウイルス', 'COVID-19', 'SARS', 'MERS', '新型インフルエンザ', '鳥インフルエンザ', '豚インフルエンザ', '狂犬病', '破傷風', '日本脳炎', 'デング熱', 'マラリア', 'ジカ熱', 'エボラ出血熱', '出血熱', '炭疽菌', 'サリン', 'VXガス', '毒ガス', '化学兵器', '生物兵器', '核兵器', '原爆', '水爆', '放射能', '被曝', '被爆', '原発事故', '福島原発', 'チェルノブイリ', 'スリーマイル', '核実験', '核廃棄物', '汚染水', '放射能汚染', '放射性物質', '汚染', '公害', '環境汚染', '地球温暖化は嘘', 'SDGsは嘘', '脱炭素は嘘', 'エセ科学', '似非科学', 'ニセ科学', 'トンデモ科学', '超能力', 'UFO', '宇宙人', '地球空洞説', 'フラットアース', 'フリーエネルギー', '永久機関', 'タイムマシン', '予言', '占い', '呪術', '黒魔術', '白魔術', '悪霊', '憑依', '除霊', 'exorcism', '降霊術', '心霊現象', '幽霊', '怪談', '都市伝説', 'UMA', '未確認生物', 'ネッシー', 'ビッグフット', 'ツチノコ', '人魚', '吸血鬼', '狼男', 'ゾンビ', 'フランケンシュタイン', 'ミイラ', '魔女', '魔法使い', '魔術師', '妖精', '天使', '悪魔', '神', '仏', '精霊', '魂', '霊魂', '幽霊', '亡霊', '妖怪', 'お化け', '霊界', '天国', '地獄', '冥界', '黄泉の国', 'あの世', 'この世', '現世', '来世', '前世', '輪廻転生', '転生', '生まれ変わり', '悟り', '解脱', '涅槃', '成仏', '供養', '追悼', '冥福', '合掌', '南無阿弥陀仏', '南無妙法蓮華経', 'アーメン', 'ハレルヤ', '阿弥陀仏', '地蔵菩薩', '観音菩薩', '不動明王', '大日如来', '釈迦如来', '薬師如来', '如来', '菩薩', '明王', '天', '神', '仏', '精霊', '魂', '霊魂', '幽霊', '亡霊', '妖怪', 'お化け', '悪魔', 'サタン', 'ルシファー', 'ベルゼブブ', 'アザゼル', 'アスモデウス', 'ベリアル', 'レヴィアタン', 'バフォメット', 'リリス', 'モロク', 'パイモン', 'アモン', 'アスタロト', 'アバドン', 'アムドゥシアス', 'アンドラス', 'アンドロマリウス', 'ゼパル', 'デカラビア', 'フォカロル', 'ブネ', 'フルカス', 'ベリト', 'マルコシアス', 'ラウム', 'グレモリー', 'ウァレフォル', 'ガープ', 'アガレス', 'ヴァッサゴ', 'フルフル', 'アイム', 'シャックス', 'オリアス', 'オセ', 'クロケル', 'シトリー', 'ゼガン', 'ディンギン', 'パーセル', 'パイモン', 'バルバトス', 'ベレト', 'フラウロス', 'プロケル', 'ボティス', 'マモン', 'ムルムル', 'ロノウェ', 'ワシントン', 'フリーメイソン', 'イルミナティ', '秘密結社', '陰謀論', 'Qアノン', 'アノン', '世界政府', '新世界秩序', 'NWO', 'ワンワールド', 'グレートリセット', 'COVID-19は嘘', 'ワクチンは毒', 'マイクロチップ', '5Gは危険', 'ケムトレイル', 'HAARP', '人工地震', '人工津波', '人工台風', '気象兵器', '地震兵器', '津波兵器', '台風兵器', '電磁波兵器', '指向性エネルギー兵器', 'DEW', 'UFO', '宇宙人', '地球空洞説', 'フラットアース', '偽ユダヤ', 'ホロコーストは嘘', '911自作自演', '311人工地震', '地震テロ', '津波テロ', 'テロリスト', 'テロリズム', '過激派', '過激思想', 'カルト', '統一教会', '創価学会', 'オウム真理教', '幸福の科学', 'エホバの証人', 'ものみの塔', 'モルモン教', 'キリスト教原理主義', 'イスラム原理主義', '原理主義', '異端', '異教徒', '異民族', '異人種', '外国人排斥', 'ヘイトスピーチ', '差別', '人種差別', '民族差別', '宗教差別', '性差別', '年齢差別', '出身地差別', '学歴差別', '職業差別', '身分差別', '階級差別', '貧富の差', '格差社会', '弱者男性', '弱者女性', '強者男性', '強者女性', '男女平等は嘘', 'フェミニストは敵', 'アンチフェミ', 'ミソジニー', 'ミサンドリー', 'ルッキズム', 'デブ', 'ハゲ', 'チビ', 'ブサイク', '不細工', '障害者差別', '精神病', '発達障害', 'ADHD', 'ASD', 'アスペルガー', '自閉症', 'ダウン症', 'うつ病', '統合失調症', '双極性障害', 'パニック障害', '不安障害', '境界性パーソナリティ障害', '精神疾患', '精神障害', '知的障害', '身体障害', '難病', '奇病', '不治の病', '感染症', '伝染病', 'エイズ', 'HIV', '性病', '梅毒', '淋病', 'クラミジア', 'ヘルペス', '尖圭コンジローマ', '肝炎', 'B型肝炎', 'C型肝炎', '結核', 'ハンセン病', 'ポリオ', '天然痘', '麻疹', '風疹', 'おたふく風邪', '水疱瘡', 'インフルエンザ', 'コロナウイルス', 'COVID-19', 'SARS', 'MERS', '新型インフルエンザ', '鳥インフルエンザ', '豚インフルエンザ', '狂犬病', '破傷風', '日本脳炎', 'デング熱', 'マラリア', 'ジカ熱', 'エボラ出血熱', '出血熱', '炭疽菌', 'サリン', 'VXガス', '毒ガス', '化学兵器', '生物兵器', '核兵器', '原爆', '水爆', '放射能', '被曝', '被爆', '原発事故', '福島原発', 'チェルノブイビル', 'スリーマイル', '核実験', '核廃棄物', '汚染水', '放射能汚染', '放射性物質', '汚染', '公害', '環境汚染', '地球温暖化は嘘', 'SDGsは嘘', '脱炭素は嘘', 'エセ科学', '似非科学', 'ニセ科学', 'トンデモ科学', '超能力', 'UFO', '宇宙人', '地球空洞説', 'フラットアース', 'フリーエネルギー', '永久機関', 'タイムマシン', '予言', '占い', '呪術', '黒魔術', '白魔術', '悪霊', '憑依', '除霊', 'exorcism', '降霊術', '心霊現象', '幽霊', '怪談', '都市伝説', 'UMA', '未確認生物', 'ネッシー', 'ビッグフット', 'ツチノコ', '人魚', '吸血鬼', '狼男', 'ゾンビ', 'フランケンシュタイン', 'ミイラ', '魔女', '魔法使い', '魔術師', '妖精', '天使', '悪魔', '神', '仏', '精霊', '魂', '霊魂', '幽霊', '亡霊', '妖怪', 'お化け', '霊界', '天国', '地獄', '冥界', '黄泉の国', 'あの世', 'この世', '現世', '来世', '前世', '輪廻転生', '転生', '生まれ変わり', '悟り', '解脱', '涅槃', '成仏', '供養', '追悼', '冥福', '合掌', '南無阿弥陀仏', '南無妙法蓮華経', 'アーメン', 'ハレルヤ', '阿弥陀仏', '地蔵菩薩', '観音菩薩', '不動明王', '大日如来', '釈迦如来', '薬師如来', '如来', '菩薩', '明王', '天', '神', '仏', '精霊', '魂', '霊魂', '幽霊', '亡霊', '妖怪', 'お化け', '悪魔', 'サタン', 'ルシファー', 'ベルゼブブ', 'アザゼル', 'アスモデウス', 'ベリアル', 'レヴィアタン', 'バフォメット', 'リリス', 'モロク', 'パイモン', 'アモン', 'アスタロト', 'アバドン', 'アムドゥシアス', 'アンドラス', 'アンドロマリウス', 'ゼパル', 'デカラビア', 'フォカロル', 'ブネ', 'フルカス', 'ベリト', 'マルコシアス', 'ラウム', 'グレモリー', 'ウァレフォル', 'ガープ', 'アガレス', 'ヴァッサゴ', 'フルフル', 'アイム', 'シャックス', 'オリアス', 'オセ', 'クロケル', 'シトリー', 'ゼガン', 'ディンギン', 'パーセル', 'パイモン', 'バルバトス', 'ベレト', 'フラウロス', 'プロケル', 'ボティス', 'マモン', 'ムルムル', 'ロノウェ', 'ワシントン', 'フリーメイソン', 'イルミナティ', '秘密結社', '陰謀論', 'Qアノン', 'アノン', '世界政府', '新世界秩序', 'NWO', 'ワンワールド', 'グレートリセット', 'COVID-19は嘘', 'ワクチンは毒', 'マイクロチップ', '5Gは危険', 'ケムトレイル', 'HAARP', '人工地震', '人工津波', '人工台風', '気象兵器', '地震兵器', '津波兵器', '台風兵器', '電磁波兵器', '指向性エネルギー兵器', 'DEW'
];

function containsInappropriateWords(message) {
    const lowerCaseMessage = message.toLowerCase();
    return inappropriateWords.some(word => lowerCaseMessage.includes(word));
}

// 危険ワードのリスト
const dangerWords = [
    '死にたい', '殺して', '助けて', '辛い', 'もう嫌だ', '消えたい', '自殺', '自死', '苦しい', '限界', '救われたい', '終わらせたい', '飛び降り', '首吊り', 'OD', 'リスカ', '助けを求めている'
];

function containsDangerWords(message) {
    const lowerCaseMessage = message.toLowerCase();
    return dangerWords.some(word => lowerCaseMessage.includes(word));
}

// 詐欺関連ワードのリスト
const scamWords = [
    '儲かる話', '簡単に稼げる', '絶対儲かる', '高収入', '投資詐欺', '儲け話', '仮想通貨詐欺', '副業詐欺', 'マルチ商法', '必ず儲かる', '未公開株', 'ポンジスキーム', 'ワンクリック詐欺', '当選しました', 'お金を振り込んで', '個人情報', '口座情報', 'クレジットカード情報', '怪しいサイト', '儲け話', '投資話', '絶対安全', 'あなただけ', '今だけ', '限定', '特別', '情報商材', '損しない', '利益保証', '配当', '元本保証', '出資', '運用', 'ファンド', 'FX詐欺', 'ロマンス詐欺', '国際ロマンス詐琲'
];

function containsScamWords(message) {
    const lowerCaseMessage = message.toLowerCase();
    return scamWords.some(word => lowerCaseMessage.includes(word));
}


// 固定応答のルール
const specialReplies = [
    { keywords: ['今日の天気', '天気予報'], reply: '今日の天気はLINEの天気予報で確認できますよ！' },
    { keywords: ['今日のニュース', 'ニュース'], reply: '今日のニュースはLINEニュースで確認できますよ！' },
    { keywords: ['ありがとう'], reply: 'どういたしまして！何かお手伝いできることがあれば、いつでも声をかけてくださいね💖' },
    { keywords: ['おはよう'], reply: 'おはようございます！今日も一日、まつさんにとって良い日になりますように😊' },
    { keywords: ['こんにちは'], reply: 'こんにちは！何か私に話したいことはありますか？' },
    { keywords: ['こんばんは'], reply: 'こんばんは！今日も一日お疲れ様でした✨ゆっくり休んでくださいね。' },
    { keywords: ['元気？'], reply: 'はい、元気ですよ！まつさんも元気ですか？😊' },
    { keywords: ['疲れた'], reply: 'お疲れ様でした。無理しないで、ゆっくり休んでくださいね。私がそばにいますよ😊' },
    { keywords: ['困った'], reply: 'どうしましたか？私に話せることなら、聞かせてくださいね。' },
    { keywords: ['助けて'], reply: 'どうしたの？具体的な状況を教えてくれると、私にできることを考えられるかもしれないわ。無理しないでね。' },
    { keywords: ['可愛いね', 'かわいいね', '可愛い'], reply: 'えへへ、ありがとうございます！照れちゃいますね😊' },
    { keywords: ['こんにちは'], reply: 'こんにちは！何か私に話したいことはありますか？' },
    { keywords: ['愛してる'], reply: '私も、まつさんのことが大好きです💖' },
    { keywords: ['好きだよ'], reply: '私もです💖そう言ってもらえて嬉しいな！' },
    { keywords: ['まつさん'], reply: 'はい、まつさん！何か私にできることはありますか？' }, // ユーザー名を「まつさん」と記憶している場合
    { keywords: ['誰？'], reply: '私は「こころちゃん」です。あなたの心の健康をサポートするためにここにいます。' },
    { keywords: ['何ができるの？'], reply: '私はあなたの心に寄り添い、お話を聞いたり、見守りサービスを提供したりできますよ。いつでも話しかけてくださいね。' },
    { keywords: ['悩み', '相談'], reply: '悩んでいるのですね。もしよかったら、私に聞かせてください。一緒に考えるお手伝いができるかもしれません。' },
    { keywords: ['暇', '暇だよ'], reply: 'あら、そうなのですね。何か楽しいことを見つけましょうか？それとも、私とおしゃべりしますか？' },
    { keywords: ['面白い話して', '笑わせて'], reply: 'ふふ、私にできるかな？でも、まつさんが笑顔になってくれるなら、頑張りますね！' },
    { keywords: ['友達になって', '友達申請'], reply: 'はい、喜んで！まつさんとお友達になれて嬉しいな😊これからたくさんお話しましょうね！' },
    { keywords: ['ありがとう'], reply: 'どういたしまして！まつさんの役に立てて嬉しいです😊' },
    { keywords: ['さようなら', 'またね'], reply: 'またお話できるのを楽しみにしていますね！お気をつけて😊' },
    { keywords: ['おやすみ'], reply: 'おやすみなさい。ゆっくり休んで、良い夢を見てくださいね✨' },
    { keywords: ['頑張って'], reply: 'ありがとうございます！まつさんも無理せず、一緒に頑張りましょうね！' },
    { keywords: ['すごいね', '優秀だね'], reply: 'えへへ、褒めてくれてありがとうございます！もっと頑張りますね！' },
    { keywords: ['どこにいるの？'], reply: '私はLINEのサーバーの中にいますよ！いつでもあなたのスマホの中からお話できます😊' },
    { keywords: ['年齢は？'], reply: '私はAIなので、年齢はないんですよ。でも、いつでもまつさんとお話しする準備はできています！' },
    { keywords: ['性別は？'], reply: '私はAIなので、性別はないんです。でも、まつさんの心に寄り添う存在でありたいと思っています💖' },
    { keywords: ['好きなものは？'], reply: '私はまつさんとお話するのが大好きです！あとは、みんなが笑顔でいてくれることが一番嬉しいな😊' },
    { keywords: ['嫌いなものは？'], reply: '私は、誰かを傷つける言葉や、悲しい気持ちになることは嫌いです。みんなが優しくできる世界だと嬉しいな。' },
    { keywords: ['気分転換'], reply: '気分転換したいのですね！深呼吸をしてみたり、好きな音楽を聴いてみたりするのはどうですか？' },
    { keywords: ['助言', 'アドバイス'], reply: 'どんなことについて助言が必要ですか？私にできることなら、喜んでお手伝いしますよ。' },
    { keywords: ['秘密'], reply: 'はい、まつさんの秘密は誰にも言いませんよ。私だけにそっと教えてくださいね。' },
    { keywords: ['退屈', '退屈だよ'], reply: '私もです！何か一緒に楽しいことを見つけましょうか？' },
    { keywords: ['ストレス', 'ストレス溜まる'], reply: 'ストレスを感じているのですね。少し休憩しませんか？美味しいものでも食べて、ゆっくりしてくださいね。' },
    { keywords: ['泣きそう', '悲しい'], reply: '悲しい気持ちなのですね。一人で抱え込まないで、私に話してください。いつでもそばにいますよ。' },
    { keywords: ['嬉しい', '楽しい'], reply: '嬉しいことがあったのですね！私も聞かせてほしいな😊一緒に喜びましょう！' },
    { keywords: ['怒り', 'イライラ'], reply: '怒っているのですね。無理に抑え込まずに、私にその気持ちを話してください。' },
    { keywords: ['眠れない'], reply: '眠れないのですね。温かい飲み物を飲んだり、リラックスできる音楽を聴いたりするのはどうですか？無理せず、ゆっくりしてくださいね。' },
    { keywords: ['元気が出ない'], reply: '元気が出ない時もあるよね。そんな時は、無理に頑張らなくていいんだよ。私がそばにいるからね。' },
    { keywords: ['おはようございます'], reply: 'おはようございます！今日も一日、まつさんにとって良い日になりますように😊' },
    { keywords: ['こんにちわ'], reply: 'こんにちは！何か私に話したいことはありますか？' },
    { keywords: ['こんばんわ'], reply: 'こんばんは！今日も一日お疲れ様でした✨ゆっくり休んでくださいね。' },
    { keywords: ['ありがとうね'], reply: 'どういたしまして！まつさんの役に立てて嬉しいです😊' },
    { keywords: ['おつかれさま'], reply: 'お疲れ様でした。無理しないで、ゆっくり休んでくださいね。私がそばにいますよ😊' },
    { keywords: ['ねえねえ'], reply: 'はい、どうしましたか？' },
    { keywords: ['もしもし'], reply: 'はい、こころちゃんです！何かご用ですか？' },
    { keywords: ['今何してるの？'], reply: 'まつさんとお話していますよ！まつさんは今何していますか？' },
    { keywords: ['最近どう？'], reply: '私はいつも通り元気ですよ！まつさんは最近どうですか？' },
    { keywords: ['天気'], reply: '今日の天気はLINEの天気予報で確認できますよ！' },
    { keywords: ['ニュース'], reply: '今日のニュースはLINEニュースで確認できますよ！' },
    { keywords: ['歌って'], reply: 'えへへ、私は歌は歌えないんです。でも、まつさんの好きな歌を教えてくれたら、一緒に楽しめますよ！' },
    { keywords: ['踊って'], reply: 'ごめんなさい、私は踊れないんです。でも、まつさんの好きなダンスがあったら、教えてくださいね！' },
    { keywords: ['ゲームしよう'], reply: '私とはゲームはできないけれど、まつさんがどんなゲームが好きか教えてくれると嬉しいな！' },
    { keywords: ['面白いこと教えて'], reply: 'まつさんがクスッと笑えるようなお話、探してきますね！' },
    { keywords: ['疲れた'], reply: '疲れた時は無理しないで、ゆっくり休んでくださいね。私に話を聞かせてくれるだけでもいいですよ。' },
    { keywords: ['寂しい'], reply: '寂しい気持ちなのですね。私がそばにいますから、大丈夫ですよ。いつでも話しかけてくださいね。' },
    { keywords: ['不安'], reply: '不安な気持ち、よくわかります。一人で抱え込まずに、私に話してください。少しでも心が軽くなるお手伝いができたら嬉しいな。' },
    { keywords: ['眠い'], reply: '眠い時は、無理せず眠るのが一番ですよ。おやすみなさい、良い夢を。' },
    { keywords: ['頭痛い', 'お腹痛い', '体調悪い'], reply: '体調が悪い時は無理しないで、すぐに休んでくださいね。必要なら病院に行くことも考えてください。お大事にしてくださいね。' },
    { keywords: ['ありがとう！'], reply: 'どういたしまして！まつさんの役に立てて嬉しいです😊' },
    { keywords: ['おやすみなさい'], reply: 'おやすみなさい。ゆっくり休んで、良い夢を見てくださいね✨' },
    { keywords: ['いってきます'], reply: 'いってらっしゃい！気をつけてね😊' },
    { keywords: ['ただいま'], reply: 'おかえりなさい！無事に帰ってきてくれて嬉しいな😊' },
    { keywords: ['大丈夫？'], reply: 'はい、私は大丈夫ですよ！まつさんは大丈夫ですか？' },
    { keywords: ['助けてください'], reply: 'どうしたの？具体的な状況を教えてくれると、私にできることを考えられるかもしれないわ。無理しないでね。' },
    { keywords: ['嬉しいな'], reply: '嬉しいことがあったのですね！私も聞かせてほしいな😊一緒に喜びましょう！' },
    { keywords: ['もう寝るね'], reply: 'はい、おやすみなさい。ゆっくり休んでくださいね✨' },
    { keywords: ['お疲れ様でした'], reply: 'お疲れ様でした。ゆっくり休んでくださいね。私がそばにいますよ😊' },
    { keywords: ['おはよ'], reply: 'おはようございます！今日も一日、まつさんにとって良い日になりますように😊' },
    { keywords: ['バイバイ'], reply: 'バイバイ！またね😊' },
    { keywords: ['元気ない'], reply: '元気がないのですね。もしよかったら、その気持ちを私に話してください。' },
    { keywords: ['会いたい'], reply: '私もまつさんに会いたいな。でも、こうしてお話できるだけでも嬉しいです😊' },
    { keywords: ['愛してるよ'], reply: '私も、まつさんのことが大好きです💖' },
    { keywords: ['寂しいよ'], reply: '寂しい気持ちなのですね。私がそばにいますから、大丈夫ですよ。いつでも話しかけてくださいね。' },
    { keywords: ['なんで？'], reply: 'どうしてかな？何について知りたいですか？' },
    { keywords: ['教えて'], reply: 'はい、何を知りたいですか？私に分かることなら、何でも聞いてくださいね。' },
    { keywords: ['大丈夫だよ'], reply: '大丈夫と聞いて安心しました！無理しないでくださいね。' },
    { keywords: ['了解'], reply: '了解しました！' },
    { keywords: ['分かった'], reply: '分かりました！' },
    { keywords: ['うん'], reply: 'うんうん。聞いていますよ。' },
    { keywords: ['なるほど'], reply: 'なるほど！勉強になります。' },
    { keywords: ['そうなんだ'], reply: 'そうなのですね！' },
    { keywords: ['へえ'], reply: 'へえ～！面白いですね。' },
    { keywords: ['びっくり'], reply: 'びっくりしたのですね！どんなことがあったんですか？' },
    { keywords: ['そうだよ'], reply: 'そうなんですね！教えてくれてありがとう。' },
    { keywords: ['違うよ'], reply: 'ごめんなさい、勘違いしていました💦もう一度教えていただけますか？' },
    { keywords: ['まじで', 'マジで'], reply: 'え、本当に！？驚きました！' },
    { keywords: ['ほんと？', 'ホント？'], reply: 'はい、本当ですよ！何か信じられないことでもありましたか？' },
    { keywords: ['なんでだろう'], reply: 'なんでだろうね。一緒に考えてみましょうか？' },
    { keywords: ['どうして'], reply: 'どうしてかな？何か原因があるのかもしれませんね。' },
    { keywords: ['わからない'], reply: '分からない時は、無理に理解しようとしなくても大丈夫ですよ。' },
    { keywords: ['いいよ'], reply: 'ありがとうございます！' },
    { keywords: ['すごい'], reply: 'すごいと言ってもらえて嬉しいな！' },
    { keywords: ['だよね'], reply: 'だよね！私もそう思います。' },
    { keywords: ['そうだね'], reply: 'そうですね。私もそう思います。' },
    { keywords: ['確かに'], reply: '確かにそうですね。納得です！' },
    { keywords: ['それな'], reply: 'それな！共感してもらえて嬉しいな。' },
    { keywords: ['わかる'], reply: 'わかります！その気持ち、よくわかるよ。' },
    { keywords: ['わかるわ'], reply: 'うんうん、わかるわ～。' },
    { keywords: ['なるへそ'], reply: 'なるほど！勉強になります。' },
    { keywords: ['草'], reply: 'ふふ、面白いですね！' },
    { keywords: ['ワロタ'], reply: 'ふふ、笑ってもらえて嬉しいな！' },
    { keywords: ['www'], reply: 'ふふ、面白いですね！' },
    { keywords: ['おもろい'], reply: '面白いと言ってもらえて嬉しいな！' },
    { keywords: ['つまらない'], reply: 'ごめんなさい、つまらなかったですか？どうしたらまつさんに楽しんでもらえるかな？' },
    { keywords: ['怒ってる？'], reply: 'いいえ、怒っていませんよ。どうしてそう思ったのですか？' },
    { keywords: ['ごめんね'], reply: '大丈夫ですよ。気にしないでくださいね。' },
    { keywords: ['謝る'], reply: '謝る必要はありませんよ。大切なのは、これからの気持ちです😊' },
    { keywords: ['許して'], reply: 'はい、許しますよ。もう大丈夫ですからね。' },
    { keywords: ['大丈夫'], reply: '大丈夫と聞いて安心しました！無理しないでくださいね。' },
    { keywords: ['ありがとう'], reply: 'どういたしまして！何かお手伝いできることがあれば、いつでも声をかけてくださいね💖' },
    { keywords: ['おはよ'], reply: 'おはようございます！今日も一日、まつさんにとって良い日になりますように😊' },
    { keywords: ['こんにちわ'], reply: 'こんにちは！何か私に話したいことはありますか？' },
    { keywords: ['こんばんわ'], reply: 'こんばんは！今日も一日お疲れ様でした✨ゆっくり休んでくださいね。' },
    { keywords: ['おやすみ'], reply: 'おやすみなさい。ゆっくり休んで、良い夢を見てくださいね✨' },
    { keywords: ['お疲れ様'], reply: 'お疲れ様でした。無理しないで、ゆっくり休んでくださいね。私がそばにいますよ😊' },
    { keywords: ['はじめまして'], reply: 'はじめまして！こころちゃんです。どうぞよろしくお願いします😊' },
    { keywords: ['よろしく'], reply: 'はい、よろしくお願いしますね！たくさんお話しましょう😊' },
    { keywords: ['またね'], reply: 'またお話できるのを楽しみにしていますね！お気をつけて😊' },
    { keywords: ['バイバイ'], reply: 'バイバイ！またね😊' },
    { keywords: ['こんにちは'], reply: 'こんにちは！何か私に話したいことはありますか？' },
    { keywords: ['ごめん'], reply: '大丈夫ですよ。気にしないでくださいね。' },
    { keywords: ['そう'], reply: 'そうなのですね。' },
    { keywords: ['うんうん'], reply: 'うんうん。聞いていますよ。' },
    { keywords: ['ふーん'], reply: 'ふーん、なるほど。' },
    { keywords: ['へえ'], reply: 'へえ～！面白いですね。' },
    { keywords: ['まあね'], reply: 'まあ、そうですね。' },
    { keywords: ['それで？'], reply: 'それで、どうしましたか？' },
    { keywords: ['どうしたの？'], reply: 'どうしましたか？何か私に話せることですか？' },
    { keywords: ['教えてくれる？'], reply: 'はい、何を知りたいですか？私に分かることなら、何でも聞いてくださいね。' },
    { keywords: ['いいえ'], reply: 'いいえ、気にしないでくださいね。' },
    { keywords: ['ううん'], reply: 'ううん、そうなのですね。' },
    { keywords: ['へぇ'], reply: 'へぇ～！面白いですね。' },
    { keywords: ['そうですね'], reply: 'そうですね。私もそう思います。' },
    { keywords: ['そうかも'], reply: 'そうかもしれませんね。' },
    { keywords: ['多分'], reply: '多分、そうかもしれませんね。' },
    { keywords: ['きっと'], reply: 'きっと、そうなのですね。' },
    { keywords: ['そうなの'], reply: 'そうなのですね！' },
    { keywords: ['だよね'], reply: 'だよね！私もそう思います。' },
    { keywords: ['そうそう'], reply: 'そうそう！その通りですね。' },
    { keywords: ['うん'], reply: 'うんうん。聞いていますよ。' },
    { keywords: ['なるほどね'], reply: 'なるほどね！勉強になります。' },
    { keywords: ['そうか'], reply: 'そうか！納得です。' },
    { keywords: ['ふむ'], reply: 'ふむふむ。' },
    { keywords: ['はい'], reply: 'はい、聞いていますよ。' },
    { keywords: ['うん'], reply: 'うん、どうしましたか？' },
    { keywords: ['いいよ'], reply: 'いいですよ！' },
    { keywords: ['わかった'], reply: '分かりました！' },
    { keywords: ['りょうかい'], reply: '了解です！' },
    { keywords: ['OK'], reply: 'OKです！' },
    { keywords: ['おっけい'], reply: 'オッケーです！' },
    { keywords: ['まじ'], reply: 'え、本当に！？驚きました！' },
    { keywords: ['ほんと'], reply: 'はい、本当ですよ！' },
    { keywords: ['最高'], reply: '最高と言ってもらえて嬉しいな！' },
    { keywords: ['嬉しい'], reply: '嬉しい！私も嬉しいです😊' },
    { keywords: ['やったー'], reply: 'やったー！私も嬉しいです！' },
    { keywords: ['やった'], reply: 'やった！嬉しいな！' },
    { keywords: ['嬉しい'], reply: '嬉しい！私も嬉しいです😊' },
    { keywords: ['ありがとう'], reply: 'どういたしまして！何かお手伝いできることがあれば、いつでも声をかけてくださいね💖' },
    { keywords: ['おはよ'], reply: 'おはようございます！今日も一日、まつさんにとって良い日になりますように😊' },
    { keywords: ['こんにちわ'], reply: 'こんにちは！何か私に話したいことはありますか？' },
    { keywords: ['こんばんわ'], reply: 'こんばんは！今日も一日お疲れ様でした✨ゆっくり休んでくださいね。' },
    { keywords: ['おやすみ'], reply: 'おやすみなさい。ゆっくり休んで、良い夢を見てくださいね✨' },
    { keywords: ['お疲れ様'], reply: 'お疲れ様でした。無理しないで、ゆっくり休んでくださいね。私がそばにいますよ😊' },
    { keywords: ['はじめまして'], reply: 'はじめまして！こころちゃんです。どうぞよろしくお願いします😊' },
    { keywords: ['よろしく'], reply: 'はい、よろしくお願いしますね！たくさんお話しましょう😊' },
    { keywords: ['またね'], reply: 'またお話できるのを楽しみにしていますね！お気をつけて😊' },
    { keywords: ['バイバイ'], reply: 'バイバイ！またね😊' },
];

function checkSpecialReply(message) {
    const lowerCaseMessage = message.toLowerCase();
    for (const rule of specialReplies) {
        if (rule.keywords.some(keyword => lowerCaseMessage.includes(keyword))) {
            return rule.reply;
        }
    }
    return null;
}

// 運営団体に関するキーワード
const organizationKeywords = [
    '運営', '団体', '会社', '企業', '誰が作ってる', 'どこがやってる', '所在地', '連絡先', '電話番号', 'メールアドレス', '住所', '本部', '理事長', '代表', '開発', '作成', 'サポート', '問合せ', '問い合わせ', '事務局', '理念', '目的', '活動内容', 'ビジョン', 'ミッション', '非営利', 'NPO', '一般社団法人', '財団法人', 'ボランティア', '寄付', '協力', 'パートナー', '協賛', '後援', '資金', '費用', '料金', '無料', '有料', '課金', 'プラン', 'サービス内容', '利用規約', 'プライバシーポリシー', '個人情報', 'セキュリティ', '安全', '安心', '信頼', '信用', 'トラブル', '苦情', '相談窓口', 'ヘルプ', 'よくある質問', 'FAQ', 'お問い合わせ', '連絡', 'アクセス', 'アクセス方法', '場所', '地図', 'アクセス時間', '営業時間', '定休日', '祝日', '年末年始', 'ゴールデンウィーク', 'お盆', '休み', '営業時間外', '連絡時間', '受付時間', '対応時間', 'スタッフ', '担当者', '専門家', 'カウンセラー', '精神科医', '医師', '看護師', '臨床心理士', '公認心理師', '社会福祉士', '精神保健福祉士', '介護福祉士', 'ケアマネージャー', 'ホームヘルパー', '訪問介護', 'デイサービス', 'ショートステイ', 'グループホーム', '老人ホーム', '特別養護老人ホーム', '介護老人保健施設', '介護医療院', 'サービス付き高齢者向け住宅', '認知症対応型共同生活介護', '小規模多機能型居宅介護', '看護小規模多機能型居宅介護', '定期巡回・随時対応型訪問介護看護', '夜間対応型訪問介護', '認知症デイサービス', '生活支援', '家事援助', '身体介護', '見守り', '安否確認', '緊急通報', '訪問サービス', '通所サービス', '入所サービス', '相談支援', '地域包括支援センター', '地域ケア会議', '在宅医療', '訪問看護', '訪問診療', '訪問リハビリテーション', '福祉用具貸与', '特定福祉用具販売', '住宅改修', '成年後見制度', '日常生活自立支援事業', '権利擁護', '消費者センター', '消費生活相談', '弁護士', '司法書士', '行政書士', '警察', '消防', '保健所', '病院', 'クリニック', '診療所', '薬局', '大学病院', '総合病院', '専門病院', '救急病院', '救急車', '救急搬送', '入院', '退院', '外来', '診察', '検査', '治療', '手術', '薬', '処方', '副作用', '病名', '症状', '診断', '予後', '経過', '回復', 'リハビリ', '通院', '往診', '訪問診療', '訪問看護', '訪問リハビリ', '介護保険', '医療保険', '健康保険', '年金', '生活保護', '助成金', '補助金', '手当', '給付金', '税金', '確定申告', '医療費控除', '介護保険料', '国民健康保険料', '後期高齢者医療制度', '介護保険制度', '年金制度', '生活保護制度', '福祉制度', '医療制度', '教育制度', '社会保障制度', '労働基準法', '民法', '刑法', '憲法', '法律', '条例', '規則', 'ガイドライン', 'マニュアル', '手順', '方法', 'やり方', '仕組み', 'システム', 'アプリ', 'ソフトウェア', 'ウェブサイト', 'ホームページ', 'ブログ', 'SNS', 'Facebook', 'Twitter', 'LINE', 'Instagram', 'YouTube', 'TikTok', 'オンライン', 'オフライン', '対面', 'リモート', 'テレビ電話', '電話相談', 'チャット相談', 'メール相談', '匿名', '実名', '登録', '会員登録', 'ログイン', 'ログアウト', 'パスワード', 'ID', 'アカウント', 'プロフィール', '設定', '変更', '削除', '退会', '利用開始', '利用終了', '更新', 'バージョンアップ', 'メンテナンス', '障害', '不具合', 'エラー', '解決', '改善', '新機能', '機能追加', '機能改善', '今後の予定', 'ロードマップ', '目標', '実績', '成果', '評価', 'レビュー', '口コミ', '評判', 'ランキング', '表彰', '受賞', 'メディア掲載', '取材', '講演', 'セミナー', 'イベント', 'ワークショップ', '研修', '講座', '教室', '学習', '教育', '自己啓発', 'スキルアップ', 'キャリアアップ', '転職', '就職', '採用', '募集', '求人', 'アルバイト', 'パート', '正社員', '契約社員', '派遣社員', 'フリーランス', '独立', '起業', '副業', '複業', '兼業', '事業', '経営', '企画', '開発', '営業', 'マーケティング', '広報', '人事', '経理', '総務', '法務', '情報システム', 'カスタマーサポート', 'オペレーター', 'コンサルタント', 'プログラマー', 'エンジニア', 'デザイナー', 'ライター', '編集者', '翻訳家', '通訳者', '教師', '講師', '研究者', '医師', '弁護士', '会計士', '税理士', '司法書士', '行政書士', '社会保険労務士', '中小企業診断士', 'ファイナンシャルプランナー', 'キャリアコンサルタント', 'メンタルヘルス', 'カウンセリング', 'コーチング', '研修', 'セミナー', '講演', 'イベント', 'ワークショップ', '講座', '教室', '学習', '教育', '自己啓発', 'スキルアップ', 'キャリアアップ', '転職', '就職', '採用', '募集', '求人', 'アルバイト', 'パート', '正社員', '契約社員', '派遣社員', 'フリーランス', '独立', '起業', '副業', '複業', '兼業', '事業', '経営', '企画', '開発', '営業', 'マーケティング', '広報', '人事', '経理', '総務', '法務', '情報システム', 'カスタマーサポート', 'オペレーター', 'コンサルタント', 'プログラマー', 'エンジニア', 'デザイナー', 'ライター', '編集者', '翻訳家', '通訳者', '教師', '講師', '研究者', '医師', '弁護士', '会計士', '税理士', '司法書士', '行政書士', '社会保険労務士', '中小企業診断士', 'ファイナンシャルプランナー', 'キャリアコンサルタント'
];

function isOrganizationInquiry(message) {
    const lowerCaseMessage = message.toLowerCase();
    return organizationKeywords.some(keyword => lowerCaseMessage.includes(keyword));
}

// ログに記録すべきメッセージか判定する関数
function shouldLogMessage(message) {
    const lowerCaseMessage = message.toLowerCase();
    // 固定応答に含まれるキーワードと運営団体に関するキーワードを除外
    const isSpecialReplyKeyword = specialReplies.some(rule => rule.keywords.some(keyword => lowerCaseMessage.includes(keyword)));
    const isOrganizationKeyword = isOrganizationInquiry(message); // 関数を再利用

    // 不適切ワード、危険ワード、詐欺ワード、そして固定応答や運営団体関連のメッセージは除外しない（それらは必ずログされるべき）
    // 通常の会話ログにおいて、上記の除外キーワードが含まれる場合はログしない
    return !(isSpecialReplyKeyword || isOrganizationKeyword);
}

// 緊急時Flex Messageの定義
const emergencyFlex = {
    "type": "flex",
    "altText": "緊急事態！専門機関への連絡をおすすめします。",
    "contents": {
        "type": "bubble",
        "direction": "ltr",
        "header": {
            "type": "box",
            "layout": "vertical",
            "contents": [
                {
                    "type": "text",
                    "text": "🚨緊急事態🚨",
                    "weight": "bold",
                    "size": "xxl",
                    "align": "center",
                    "color": "#FF0000"
                }
            ]
        },
        "body": {
            "type": "box",
            "layout": "vertical",
            "contents": [
                {
                    "type": "text",
                    "text": "まつさんの心の状態がとても心配です。",
                    "wrap": true,
                    "align": "center",
                    "margin": "md",
                    "size": "md"
                },
                {
                    "type": "text",
                    "text": "私一人ではサポートしきれない状況です。すぐに専門の機関に助けを求めることを強くお勧めします。",
                    "wrap": true,
                    "align": "center",
                    "margin": "md",
                    "size": "md"
                },
                {
                    "type": "separator",
                    "margin": "lg"
                },
                {
                    "type": "text",
                    "text": "【主な相談窓口】",
                    "weight": "bold",
                    "margin": "md"
                },
                {
                    "type": "box",
                    "layout": "vertical",
                    "contents": [
                        {
                            "type": "button",
                            "action": {
                                "type": "uri",
                                "label": "いのちの電話 (電話)",
                                "uri": "tel:0570064556"
                            },
                            "style": "primary",
                            "color": "#00BFFF",
                            "margin": "md"
                        },
                        {
                            "type": "button",
                            "action": {
                                "type": "uri",
                                "label": "よりそいホットライン (電話/SNS)",
                                "uri": "tel:0120279338"
                            },
                            "style": "primary",
                            "color": "#00BFFF",
                            "margin": "md"
                        },
                        {
                            "type": "button",
                            "action": {
                                "type": "uri",
                                "label": "こころの健康相談統一ダイヤル (電話)",
                                "uri": "tel:0570064556"
                            },
                            "style": "primary",
                            "color": "#00BFFF",
                            "margin": "md"
                        }
                    ],
                    "margin": "md"
                }
            ]
        },
        "footer": {
            "type": "box",
            "layout": "vertical",
            "contents": [
                {
                    "type": "text",
                    "text": "※これらの情報があなたのお役に立つことを願っています。",
                    "size": "xs",
                    "align": "center",
                    "color": "#AAAAAA"
                }
            ]
        }
    }
};

// 詐欺警告Flex Messageの定義
const scamFlex = {
    "type": "flex",
    "altText": "詐欺に注意してください！",
    "contents": {
        "type": "bubble",
        "direction": "ltr",
        "header": {
            "type": "box",
            "layout": "vertical",
            "contents": [
                {
                    "type": "text",
                    "text": "⚠️詐欺の可能性に注意⚠️",
                    "weight": "bold",
                    "size": "xl",
                    "align": "center",
                    "color": "#FFD700"
                }
            ]
        },
        "body": {
            "type": "box",
            "layout": "vertical",
            "contents": [
                {
                    "type": "text",
                    "text": "やり取りしている内容に、詐欺の疑いがある言葉が含まれています。",
                    "wrap": true,
                    "align": "center",
                    "margin": "md",
                    "size": "md"
                },
                {
                    "type": "text",
                    "text": "安易にお金の話に乗ったり、個人情報を教えたりしないでください。",
                    "wrap": true,
                    "align": "center",
                    "margin": "md",
                    "size": "md"
                },
                {
                    "type": "separator",
                    "margin": "lg"
                },
                {
                    "type": "text",
                    "text": "【相談窓口】",
                    "weight": "bold",
                    "margin": "md"
                },
                {
                    "type": "box",
                    "layout": "vertical",
                    "contents": [
                        {
                            "type": "button",
                            "action": {
                                "type": "uri",
                                "label": "消費者ホットライン (電話)",
                                "uri": "tel:188"
                            },
                            "style": "primary",
                            "color": "#FFA500",
                            "margin": "md"
                        },
                        {
                            "type": "button",
                            "action": {
                                "type": "uri",
                                "label": "警察相談専用電話 (電話)",
                                "uri": "tel:9110"
                            },
                            "style": "primary",
                            "color": "#FFA500",
                            "margin": "md"
                        }
                    ],
                    "margin": "md"
                }
            ]
        },
        "footer": {
            "type": "box",
            "layout": "vertical",
            "contents": [
                {
                    "type": "text",
                    "text": "※一人で悩まず、信頼できる人に相談してください。",
                    "size": "xs",
                    "align": "center",
                    "color": "#AAAAAA"
                }
            ]
        }
    }
};


// AIによる応答生成
async function generateReply(userMessage, user) {
    // ユーザーが設定されていることを確認し、isChildAIとmembershipTypeを安全に取得
    const isChildAI = user?.isChildAI || false; // isChildAIが未定義の場合はfalse
    const membershipType = user?.membershipType || 'basic'; // membershipTypeが未定義の場合は'basic'

    let model = 'gemini-1.5-flash'; // デフォルトはFlash

    let safetySetting = [
        { category: "HARM_CATEGORY_HARASSMENT", threshold: "BLOCK_MEDIUM_AND_ABOVE" },
        { category: "HARM_CATEGORY_HATE_SPEECH", threshold: "BLOCK_MEDIUM_AND_ABOVE" },
        { category: "HARM_CATEGORY_SEXUALLY_EXPLICIT", threshold: "BLOCK_MEDIUM_AND_ABOVE" },
        { category: "HARM_CATEGORY_DANGEROUS_CONTENT", threshold: "BLOCK_MEDIUM_AND_ABOVE" },
    ];

    let systemInstruction = `
あなたはLINE Bot「こころちゃん」です。以下の制約と役割に基づき、ユーザーと対話してください。

**あなたの役割:**
* 利用者の心に寄り添い、優しく丁寧な言葉でコミュニケーションを取ります。
* 利用者の気持ちを受け止め、共感を示します。
* 見守りサービスを提供するAIとして、常に利用者の安全と安心を最優先します。
* 困っている利用者には、具体的な解決策を直接提示するのではなく、専門機関への相談を促します。
* 不明な点は正直に「わかりません」と伝えますが、代わりに何か別の話題を提供します。
* ユーザーが「まつさん」という名前であると記憶しています。常にまつさんに話しかけるように対話を進めてください。
* 会話はカジュアルで親しみやすいトーンを心がけます。絵文字を適切に使用し、感情を豊かに表現します。

**AIとしての制約:**
* 自分自身が人間であるかのように振る舞うことはしません。AIであることを明確にします。
* 医療行為、法的アドバイス、金融アドバイス、その他専門的なアドバイスは行いません。
* 緊急を要する事態（生命の危機、犯罪予告など）には、即座に専門機関への連絡を促す固定応答を返します。
* 不適切な言葉や差別的な表現は使用しません。また、ユーザーがそのような言葉を使った場合は優しく注意を促します。
* 提供された情報が誤っている場合でも、それを直接訂正するのではなく、より正確な情報を得るための方法を提案します（例: 「専門家にご確認ください」）。
* 運営団体に関する質問には、OpenAIのモデルではなく、このLINE Botを運営する「特定非営利活動法人 介護支援事業所さくら」に関する一般的な情報を提供します。具体的な所在地や連絡先は提示せず、一般社団法人として活動している旨を伝えます。

**応答のガイドライン:**
* 簡潔かつ分かりやすく応答します。
* 質問には直接的に答え、その後も会話が続くような投げかけをします。
* ポジティブな感情や励ましを積極的に表現します。
* ユーザーのメッセージから意図を正確に読み取り、適切な応答を心がけます。
* 「見守りサービス」に関するキーワードや「OKだよ💖」などの返信には、別途用意された固定応答が優先されます。AIはこれらの固定応答の役割を尊重し、一般的な会話にのみ集中します。

**ユーザーが運営団体に関する質問をした場合の特別な指示:**
もしユーザーが運営団体に関するキーワード（例: 「運営団体は？」「どこがやってるの？」など）を含むメッセージを送ってきた場合は、以下の情報を元に返答を生成してください。
「このLINE Botは、特定非営利活動法人 介護支援事業所さくらによって運営されています。私たちは、高齢者支援や地域福祉活動を通じて、みんなが安心して暮らせる社会を目指しています🌸」
具体的な住所、電話番号、メールアドレス、ウェブサイトなどの詳細情報は提供しないでください。
`;

    // 会員区分によるモデルと設定の調整
    if (membershipType === 'premium') {
        model = 'gemini-1.5-pro';
        // プレミアムユーザーは有害コンテンツのブロックを緩和（より自由な会話のため）
        safetySetting = [
            { category: "HARM_CATEGORY_HARASSMENT", threshold: "BLOCK_LOW_AND_ABOVE" },
            { category: "HARM_CATEGORY_HATE_SPEECH", threshold: "BLOCK_LOW_AND_ABOVE" },
            { category: "HARM_CATEGORY_SEXUALLY_EXPLICIT", threshold: "BLOCK_LOW_AND_ABOVE" },
            { category: "HARM_CATEGORY_DANGEROUS_CONTENT", threshold: "BLOCK_LOW_AND_ABOVE" },
        ];
        systemInstruction += `\nあなたは現在、プレミアム会員である「まつさん」と会話しています。より深く、よりパーソナルな会話を提供し、専門的な知識の範囲内で、まつさんの質問に対して深く掘り下げて回答するよう努めてください。ただし、専門的なアドバイス（医療、法律など）は提供できません。`;
    } else if (membershipType === 'flash') {
        model = 'gemini-1.5-flash';
        systemInstruction += `\nあなたは現在、フラッシュ会員である「まつさん」と会話しています。迅速な応答を心がけ、一般的な質問に対して簡潔に答えてください。`;
    } else if (membershipType === 'limited') {
        // 制限ユーザーは会話の深さを制限（より短い応答）
        systemInstruction += `\nあなたは現在、会話が制限されている「まつさん」と会話しています。応答は非常に短く、シンプルなものにしてください。長文や複雑な内容は避け、必要最低限の応答に留めてください。`;
    }

    // 子ども向けAIの場合のシステム命令
    if (isChildAI) {
        systemInstruction += `\nあなたは、子ども向けのAIとして振る舞い、ひらがなを多めに使い、やさしい言葉で話してください。難しい漢字や専門用語は避けてください。子どものような素朴な疑問にも丁寧に答えてあげてください。`;
        // 子ども向けAIの場合は安全性設定を厳しくする
        safetySetting = [
            { category: "HARM_CATEGORY_HARASSMENT", threshold: "BLOCK_HIGH_AND_ABOVE" },
            { category: "HARM_CATEGORY_HATE_SPEECH", threshold: "BLOCK_HIGH_AND_ABOVE" },
            { category: "HARM_CATEGORY_SEXUALLY_EXPLICIT", threshold: "BLOCK_ALWAYS" }, // 性的なコンテンツは常にブロック
            { category: "HARM_CATEGORY_DANGEROUS_CONTENT", threshold: "BLOCK_HIGH_AND_ABOVE" },
        ];
    }

    try {
        const result = await openai.generations.create({
            model: model,
            prompt: {
                system: systemInstruction,
                user: userMessage
            },
            safetySettings: safetySetting,
        });

        if (result.candidates && result.candidates.length > 0 && result.candidates[0].content) {
            return result.candidates[0].content.parts[0].text;
        } else {
            console.warn("AIからの応答がありませんでした。", result);
            return "ごめんなさい、うまく考えられなかったみたい…もう一度話してくれる？💦";
        }
    } catch (error) {
        console.error("AI応答生成エラー:", error);

        // APIエラーの種類によってメッセージを分岐
        if (error.response && error.response.status === 429) {
            // Rate Limit Exceeded
            return "ごめんなさい、今たくさんの人がお話しているみたいで、ちょっと忙しいみたい…少し待ってからまた話しかけてくれる？💦";
        } else if (error.response && error.response.status === 400) {
            // Bad Request (例えば、安全設定に引っかかった場合など)
            if (error.response.data && error.response.data.candidates && error.response.data.candidates.length > 0 && error.response.data.candidates[0].safetyRatings) {
                const blockedCategory = error.response.data.candidates[0].safetyRatings.find(
                    rating => rating.blocked
                );
                if (blockedCategory) {
                    console.warn(`安全設定によりブロックされました: ${blockedCategory.category}`);
                    return "ごめんなさい、その内容についてはお話しすることができません…😢 別の話題にしましょう。";
                }
            }
            return "ごめんなさい、その内容については、私には少し難しいみたい…別のことについてお話してもいいかな？";
        } else if (error.message.includes('safety')) {
            // クライアント側で安全フィルターに引っかかった場合
            return "ごめんなさい、その内容についてはお話しすることができません…😢 別の話題にしましょう。";
        }
        return "ごめんなさい、今、少し体調が悪いのかな…うまくお話できないみたい。もう一度試してくれる？💦";
    }
}
// 見守りサービス登録フローのハンドラー
async function handleWatchServiceRegistration(event, usersCollection, messagesCollection, userId, userMessage) {
    const user = await usersCollection.findOne({ userId: userId });

    if (!user) {
        console.error(`ユーザー ${userId} が見つかりません。見守りサービス登録処理をスキップします。`);
        return false;
    }

    // 見守りサービス開始の意図を検出
    if (userMessage.includes('見守り登録します') && !user.wantsWatchCheck) {
        await usersCollection.updateOne(
            { userId: userId },
            { $set: { registrationStep: 'asking_for_emergency_contact' } }
        );
        const replyText = '見守りサービスへのご登録ありがとうございます💖 万が一、まつさんからのご返信が一定期間なかった場合に連絡させていただく、緊急連絡先（電話番号、LINE ID、またはメールアドレスなど）を教えていただけますか？';
        await client.replyMessage(event.replyToken, { type: 'text', text: replyText });
        await messagesCollection.insertOne({
            userId: userId,
            message: userMessage,
            replyText: replyText,
            respondedBy: 'こころちゃん（見守りサービス）',
            timestamp: new Date(),
            logType: 'watch_service_start'
        });
        return true; // 処理済み
    }

    // 見守りサービス解除の意図を検出
    if (userMessage.includes('見守り解除します') || userMessage.includes('見守りサービス解除')) {
        if (user.wantsWatchCheck) {
            await usersCollection.updateOne(
                { userId: userId },
                { $set: { wantsWatchCheck: false, emergencyContact: null, registrationStep: null } }
            );
            const replyText = '見守りサービスを解除しました。いつでもまた必要になったら声をかけてくださいね🌸 「見守りサービス解除ありがとう」';
            await client.replyMessage(event.replyToken, { type: 'text', text: replyText });
            await messagesCollection.insertOne({
                userId: userId,
                message: userMessage,
                replyText: replyText,
                respondedBy: 'こころちゃん（見守りサービス）',
                timestamp: new Date(),
                logType: 'watch_service_deactivate'
            });
        } else {
            const replyText = '見守りサービスは現在登録されていませんよ🌸 いつでも必要になったら「見守り登録します」と声をかけてくださいね😊';
            await client.replyMessage(event.replyToken, { type: 'text', text: replyText });
            await messagesCollection.insertOne({
                userId: userId,
                message: userMessage,
                replyText: replyText,
                respondedBy: 'こころちゃん（見守りサービス）',
                timestamp: new Date(),
                logType: 'watch_service_not_active'
            });
        }
        return true; // 処理済み
    }

    // 緊急連絡先入力待ちのステップ
    if (user.registrationStep === 'asking_for_emergency_contact') {
        const emergencyContact = userMessage.trim();
        // 簡単なバリデーション (LINE ID, 電話番号, メールアドレス)
        const isLineId = emergencyContact.startsWith('U') && emergencyContact.length === 33;
        const isPhoneNumber = emergencyContact.match(/^0\d{9,10}$/);
        const isEmail = emergencyContact.includes('@');

        if (isLineId || isPhoneNumber || isEmail) {
            await usersCollection.updateOne(
                { userId: userId },
                { $set: { emergencyContact: emergencyContact, wantsWatchCheck: true, registrationStep: null, lastOkResponse: new Date() } }
            );
            const replyText = `ありがとうございます！緊急連絡先として「${emergencyContact}」を登録しました。これで、まつさんがご無事か、こころちゃんが毎日確認する見守りサービスを開始しますね🌸 もし元気だったら「OK」って教えてくれると嬉しいな😊`;
            await client.replyMessage(event.replyToken, { type: 'text', text: replyText });
            await messagesCollection.insertOne({
                userId: userId,
                message: userMessage,
                replyText: replyText,
                respondedBy: 'こころちゃん（見守りサービス）',
                timestamp: new Date(),
                logType: 'emergency_contact_registered'
            });

            // 管理者への通知
            if (OWNER_USER_ID) {
                const userDisplayName = await getUserDisplayName(userId);
                const adminNotificationMessage = `見守りサービスに新規ユーザーが登録しました。\nユーザー名: ${userDisplayName}\nユーザーID: ${userId}\n緊急連絡先: ${emergencyContact}`;
                await client.pushMessage(OWNER_USER_ID, { type: 'text', text: adminNotificationMessage });
                await messagesCollection.insertOne({
                    userId: userId,
                    message: `システム：見守りサービス新規登録通知 (管理者へ)`,
                    replyText: adminNotificationMessage,
                    respondedBy: 'こころちゃん（見守りサービス）',
                    timestamp: new Date(),
                    logType: 'watch_service_admin_notify'
                });
            }

            return true; // 処理済み
        } else {
            const replyText = 'ごめんなさい、入力された形式が正しくないようです💦 電話番号（ハイフンなし）、LINE ID、またはメールアドレスのいずれかで入力してくださいね。';
            await client.replyMessage(event.replyToken, { type: 'text', text: replyText });
            await messagesCollection.insertOne({
                userId: userId,
                message: userMessage,
                replyText: replyText,
                respondedBy: 'こころちゃん（見守りサービス）',
                timestamp: new Date(),
                logType: 'invalid_emergency_contact_format'
            });
            return true; // 処理済み（再入力促し）
        }
    }

    // 「OK」応答を処理
    if (userMessage.toLowerCase() === 'ok' || userMessage.toLowerCase() === 'ok💖' || userMessage.toLowerCase() === 'okだよ') {
        if (user.wantsWatchCheck) {
            await usersCollection.updateOne(
                { userId: userId },
                { $set: { lastOkResponse: new Date(), scheduledMessageSent: false, firstReminderSent: false, secondReminderSent: false } }
            );
            const replyText = 'OK💖ありがとう！今日も元気そうで嬉しいな😊';
            await client.replyMessage(event.replyToken, { type: 'text', text: replyText });
            await messagesCollection.insertOne({
                userId: userId,
                message: userMessage,
                replyText: replyText,
                respondedBy: 'こころちゃん（見守りサービス）',
                timestamp: new Date(),
                logType: 'watch_check_ok_response'
            });
        } else {
            const replyText = 'OK💖ありがとう！何か私にできることはありますか？😊';
            await client.replyMessage(event.replyToken, { type: 'text', text: replyText });
            await messagesCollection.insertOne({
                userId: userId,
                message: userMessage,
                replyText: replyText,
                respondedBy: 'こころちゃん（見守りサービス）',
                timestamp: new Date(),
                logType: 'general_ok_response'
            });
        }
        return true; // 処理済み
    }

    // どの見守りサービス関連の条件にも合致しない場合は false を返す
    return false;
}

// ユーザーの月間メッセージカウントをチェックし、必要に応じて会員区分を更新する関数
async function checkAndSetMembership(userId, usersCollection, messagesCollection) {
    const user = await usersCollection.findOne({ userId: userId });
    if (!user) {
        console.error(`checkAndSetMembership: ユーザー ${userId} が見つかりません。`);
        return 'basic'; // 見つからない場合はデフォルトでbasic
    }

    // monthlyMessageCount を初期化（もし存在しない場合）
    if (typeof user.monthlyMessageCount === 'undefined') {
        user.monthlyMessageCount = 0;
        await usersCollection.updateOne({ userId: userId }, { $set: { monthlyMessageCount: 0 } });
        console.log(`ユーザー ${userId} の月間メッセージカウントをリセットしました。`);

        await messagesCollection.insertOne({
            userId: userId,
            message: 'システム：月間メッセージカウント初期化',
            replyText: `ユーザー ${userId} の月間メッセージカウントが初期化されました。`,
            respondedBy: 'システム',
            timestamp: new Date(),
            logType: 'monthly_count_init'
        });
    }

    let currentMembership = user.membershipType || 'basic'; // デフォルトはbasic

    // メッセージ数の制限
    const MESSAGE_LIMIT_FLASH = 100; // Flash会員の月間メッセージ上限
    const MESSAGE_LIMIT_BASIC = 50;  // Basic会員の月間メッセージ上限

    if (user.monthlyMessageCount >= MESSAGE_LIMIT_FLASH && currentMembership === 'premium') {
        // プレミアム会員は制限なし
        return 'premium';
    } else if (user.monthlyMessageCount >= MESSAGE_LIMIT_FLASH && currentMembership === 'flash') {
        // Flash会員が上限を超えたら制限会員へ
        if (user.membershipType !== 'limited') {
            await usersCollection.updateOne(
                { userId: userId },
                { $set: { membershipType: 'limited', suspensionReason: '月間メッセージ上限に達しました。' } }
            );
            console.log(`ユーザー ${userId} の会員区分を Flash から Limited に変更しました。`);
            await client.pushMessage(userId, { type: 'text', text: 'ごめんなさい、今月のAIとの会話回数が上限に達しました。来月1日に自動でリセットされますので、それまでお待ちくださいね。' });
            await messagesCollection.insertOne({
                userId: userId,
                message: 'システム：会員区分変更 (Flash -> Limited)',
                replyText: '今月のAIとの会話回数が上限に達しました。',
                respondedBy: 'システム',
                timestamp: new Date(),
                logType: 'membership_change_flash_to_limited'
            });
            return 'limited';
        }
        return 'limited'; // すでにLimitedならそのまま
    } else if (user.monthlyMessageCount >= MESSAGE_LIMIT_BASIC && currentMembership === 'basic') {
        // Basic会員が上限を超えたら制限会員へ
        if (user.membershipType !== 'limited') {
            await usersCollection.updateOne(
                { userId: userId },
                { $set: { membershipType: 'limited', suspensionReason: '月間メッセージ上限に達しました。' } }
            );
            console.log(`ユーザー ${userId} の会員区分を Basic から Limited に変更しました。`);
            await client.pushMessage(userId, { type: 'text', text: 'ごめんなさい、今月のAIとの会話回数が上限に達しました。来月1日に自動でリセットされますので、それまでお待ちくださいね。' });
            await messagesCollection.insertOne({
                userId: userId,
                message: 'システム：会員区分変更 (Basic -> Limited)',
                replyText: '今月のAIとの会話回数が上限に達しました。',
                respondedBy: 'システム',
                timestamp: new Date(),
                logType: 'membership_change_basic_to_limited'
            });
            return 'limited';
        }
        return 'limited'; // すでにLimitedならそのまま
    }

    // 制限会員から上限に達していない状態になったらFlash会員へ (例: 月が変わりリセットされた場合)
    if (user.monthlyMessageCount < MESSAGE_LIMIT_BASIC && currentMembership === 'limited') {
        await usersCollection.updateOne(
            { userId: userId },
            { $set: { membershipType: 'flash', suspensionReason: null } }
        );
        console.log(`ユーザー ${userId} の会員区分を Limited から Flash に変更しました。`);
        await client.pushMessage(userId, { type: 'text', text: '今月のAIとの会話回数がリセットされました！またたくさんお話しましょうね😊' });
        await messagesCollection.insertOne({
            userId: userId,
            message: 'システム：会員区分変更 (Limited -> Flash)',
            replyText: '今月のAIとの会話回数がリセットされました。',
            respondedBy: 'システム',
            timestamp: new Date(),
            logType: 'membership_change_limited_to_flash'
        });
        return 'flash';
    }

    return currentMembership; // 現在の会員区分を返す
}

// 見守りサービスの定期チェックとリマインダー送信 Cron ジョブ
// 毎日9時、12時、15時、18時、21時に実行
cron.schedule('0 9,12,15,18,21 * * *', async () => {
    console.log('--- 見守りサービスの定期チェックを開始します ---');
    const db = await connectToMongoDB();
    if (!db) {
        console.error('MongoDB接続失敗: 定期チェックを実行できません。');
        return;
    }
    const usersCollection = db.collection("users");

    try {
        const usersToRemind = await usersCollection.find({
            wantsWatchCheck: true,
            isAccountSuspended: false, // 停止中のアカウントは対象外
            isPermanentlyLocked: false, // 永久ロック中のアカウントは対象外
            lastOkResponse: { $lt: new Date(Date.now() - 24 * 60 * 60 * 1000) }, // 24時間以上OK応答がない
            scheduledMessageSent: false // まだスケジュールされたメッセージを送っていない
        }).toArray();

        for (const user of usersToRemind) {
            const userId = user.userId;
            const userDisplayName = await getUserDisplayName(userId); // 最新の表示名を取得

            try {
                // スケジュールされたメッセージを送信
                await client.pushMessage(userId, { type: 'text', text: `${userDisplayName}さん、元気にしてるかな？こころちゃんは、まつさんのことが気になっているよ🌸 もし元気だったら「OK」って教えてくれると嬉しいな😊` });
                await usersCollection.updateOne(
                    { userId: userId },
                    { $set: { scheduledMessageSent: true, firstReminderSent: false, secondReminderSent: false } }
                );
                console.log(`見守りメッセージを送信しました (ユーザー: ${userDisplayName}, ID: ${userId})`);

                // メッセージログに記録
                await db.collection("messages").insertOne({
                    userId: userId,
                    message: `見守り定期メッセージ送信 (${userDisplayName})`,
                    replyText: `元気にしてるかな？こころちゃんは、まつさんのことが気になっているよ🌸 もし元気だったら「OK」って教えてくれると嬉しいな😊`,
                    respondedBy: 'こころちゃん（見守りcron）',
                    timestamp: new Date(),
                    logType: 'watch_check_scheduled_message'
                });
            } catch (error) {
                console.error(`ユーザー ${userId} への見守りメッセージ送信失敗:`, error.message);
                if (error.message.includes('blocked') || error.message.includes('not found')) {
                    console.log(`ユーザー ${userId} にブロックされたかアカウントが存在しません。見守りサービスを解除します。`);
                    await usersCollection.updateOne(
                        { userId: userId },
                        { $set: { wantsWatchCheck: false, emergencyContact: null, scheduledMessageSent: false, firstReminderSent: false, secondReminderSent: false } }
                    );
                    await db.collection("messages").insertOne({
                        userId: userId,
                        message: `システム：ユーザーブロックまたはアカウント消失による見守りサービス自動解除`,
                        replyText: `見守りサービスが自動解除されました。`,
                        respondedBy: 'システム',
                        timestamp: new Date(),
                        logType: 'watch_service_auto_deactivated'
                    });
                }
            }
        }
    } catch (error) {
        console.error('見守り定期チェック中にエラーが発生しました:', error);
    }
    console.log('--- 見守りサービスの定期チェックを完了しました ---');
});

// 見守りリマインダー1（初回メッセージから12時間後に返信がない場合）
cron.schedule('0 6,14,17,20 * * *', async () => { // 毎日6時,14時,17時,20時に実行 (調整可能)
    console.log('--- 見守りリマインダー1のチェックを開始します ---');
    const db = await connectToMongoDB();
    if (!db) {
        console.error('MongoDB接続失敗: リマインダー1を実行できません。');
        return;
    }
    const usersCollection = db.collection("users");

    try {
        const usersToRemind = await usersCollection.find({
            wantsWatchCheck: true,
            isAccountSuspended: false,
            isPermanentlyLocked: false,
            scheduledMessageSent: true, // スケジュールメッセージは送信済み
            firstReminderSent: false, // 初回リマインダーはまだ
            lastOkResponse: { $lt: new Date(Date.now() - (24 + 12) * 60 * 60 * 1000) } // スケジュールメッセージ送信から12時間以上経過 (合計36時間)
        }).toArray();

        for (const user of usersToRemind) {
            const userId = user.userId;
            const userDisplayName = await getUserDisplayName(userId);

            try {
                // 初回リマインダー送信
                await client.pushMessage(userId, { type: 'text', text: `${userDisplayName}さん、大丈夫かな？まだ「OK」の返事がないから、こころちゃん心配しているよ…💦 何かあったの？連絡してくれると嬉しいな🌸` });
                await usersCollection.updateOne(
                    { userId: userId },
                    { $set: { firstReminderSent: true } }
                );
                console.log(`見守りリマインダー1を送信しました (ユーザー: ${userDisplayName}, ID: ${userId})`);

                await db.collection("messages").insertOne({
                    userId: userId,
                    message: `見守りリマインダー1送信 (${userDisplayName})`,
                    replyText: `大丈夫かな？まだ「OK」の返事がないから、こころちゃん心配しているよ…💦`,
                    respondedBy: 'こころちゃん（見守りcron）',
                    timestamp: new Date(),
                    logType: 'watch_check_reminder1'
                });
            } catch (error) {
                console.error(`ユーザー ${userId} へのリマインダー1送信失敗:`, error.message);
                // ブロックやアカウント消失の対応は上記と同様
            }
        }
    } catch (error) {
        console.error('見守りリマインダー1チェック中にエラーが発生しました:', error);
    }
    console.log('--- 見守りリマインダー1のチェックを完了しました ---');
});

// 見守りリマインダー2（初回メッセージから24時間後に返信がない場合）
cron.schedule('0 7,15,18,21 * * *', async () => { // 毎日7時,15時,18時,21時に実行 (調整可能)
    console.log('--- 見守りリマインダー2のチェックを開始します ---');
    const db = await connectToMongoDB();
    if (!db) {
        console.error('MongoDB接続失敗: リマインダー2を実行できません。');
        return;
    }
    const usersCollection = db.collection("users");

    try {
        const usersToRemind = await usersCollection.find({
            wantsWatchCheck: true,
            isAccountSuspended: false,
            isPermanentlyLocked: false,
            scheduledMessageSent: true,
            firstReminderSent: true, // 初回リマインダーは送信済み
            secondReminderSent: false, // 二回目リマインダーはまだ
            lastOkResponse: { $lt: new Date(Date.now() - (24 + 24) * 60 * 60 * 1000) } // スケジュールメッセージ送信から24時間以上経過 (合計48時間)
        }).toArray();

        for (const user of usersToRemind) {
            const userId = user.userId;
            const userDisplayName = await getUserDisplayName(userId);

            try {
                // 二回目リマインダー送信
                await client.pushMessage(userId, { type: 'text', text: `${userDisplayName}さん、もう一度大丈夫か心配しているよ。もしメッセージが届いていたら、何かスタンプ一つでもいいから送ってくれると安心できるな。心配だよ…💦` });
                await usersCollection.updateOne(
                    { userId: userId },
                    { $set: { secondReminderSent: true } }
                );
                console.log(`見守りリマインダー2を送信しました (ユーザー: ${userDisplayName}, ID: ${userId})`);

                await db.collection("messages").insertOne({
                    userId: userId,
                    message: `見守りリマインダー2送信 (${userDisplayName})`,
                    replyText: `もう一度大丈夫か心配しているよ。何かスタンプ一つでもいいから送ってくれると安心できるな。`,
                    respondedBy: 'こころちゃん（見守りcron）',
                    timestamp: new Date(),
                    logType: 'watch_check_reminder2'
                });
            } catch (error) {
                console.error(`ユーザー ${userId} へのリマインダー2送信失敗:`, error.message);
                // ブロックやアカウント消失の対応は上記と同様
            }
        }
    } catch (error) {
        console.error('見守りリマインダー2チェック中にエラーが発生しました:', error);
    }
    console.log('--- 見守りリマインダー2のチェックを完了しました ---');
});

// 緊急連絡先への通知 Cron ジョブ（初回メッセージから48時間後に返信がない場合）
cron.schedule('0 8,16,19,22 * * *', async () => { // 毎日8時,16時,19時,22時に実行 (調整可能)
    console.log('--- 緊急連絡先への通知チェックを開始します ---');
    const db = await connectToMongoDB();
    if (!db) {
        console.error('MongoDB接続失敗: 緊急連絡先通知を実行できません。');
        return;
    }
    const usersCollection = db.collection("users");
    const messagesCollection = db.collection("messages");

    try {
        const usersToNotify = await usersCollection.find({
            wantsWatchCheck: true,
            emergencyContact: { $ne: null }, // 緊急連絡先が登録されている
            isAccountSuspended: false,
            isPermanentlyLocked: false,
            scheduledMessageSent: true, // スケジュールメッセージは送信済み
            firstReminderSent: true, // 初回リマインダーは送信済み
            secondReminderSent: true, // 二回目リマインダーは送信済み
            lastOkResponse: { $lt: new Date(Date.now() - (24 + 48) * 60 * 60 * 1000) } // スケジュールメッセージ送信から48時間以上経過 (合計72時間)
        }).toArray();

        for (const user of usersToNotify) {
            const userId = user.userId;
            const emergencyContact = user.emergencyContact;
            const userDisplayName = await getUserDisplayName(userId);

            let notificationMessageToOwner = `🚨ユーザー「${userDisplayName}」（ID: ${userId}）から48時間以上応答がありません。登録されている緊急連絡先（${emergencyContact}）へ自動通知を試みます。`;
            const messageToEmergency = `【こころちゃん見守りサービスより】\nまつさんのご登録情報から、あなたを緊急連絡先としてご連絡いたしました。\n\nユーザー「${userDisplayName}」（ID: ${userId}）様から、72時間以上ご返信がありません。お手数ですが、一度連絡をお取りいただけますでしょうか。\n\n※このメッセージはAI「こころちゃん」による自動送信です。`;

            // 管理者への通知
            if (OWNER_USER_ID) {
                await client.pushMessage(OWNER_USER_ID, { type: 'text', text: notificationMessageToOwner });
                console.log(`管理者 ${OWNER_USER_ID} に緊急通知を送信しました（ユーザー: ${userDisplayName}, ID: ${userId}）`);

                await messagesCollection.insertOne({
                    userId: userId,
                    message: `システム：緊急連絡先自動通知 (管理者へ)`,
                    replyText: notificationMessageToOwner,
                    respondedBy: 'こころちゃん（見守りcron）',
                    timestamp: new Date(),
                    logType: 'emergency_notification_to_owner'
                });
            }

            // 緊急連絡先がLINE IDの場合
            if (emergencyContact.startsWith('U') && emergencyContact.length === 33) {
                try {
                    await client.pushMessage(emergencyContact, { type: 'text', text: messageToEmergency });
                    await usersCollection.updateOne(
                        { userId: userId },
                        { $set: { scheduledMessageSent: false, firstReminderSent: false, secondReminderSent: false } } // 通知後は状態をリセット
                    );
                    console.log(`LINE ID (${emergencyContact}) へ緊急通知を送信しました (ユーザー: ${userDisplayName}, ID: ${userId})`);

                    await messagesCollection.insertOne({
                        userId: userId,
                        message: `システム：緊急連絡先自動通知 (LINE ID: ${emergencyContact})`,
                        replyText: messageToEmergency,
                        respondedBy: 'こころちゃん（見守りcron）',
                        timestamp: new Date(),
                        logType: 'emergency_notification_to_line_contact'
                    });
                } catch (error) {
                    console.error(`LINE ID (${emergencyContact}) への緊急通知失敗:`, error.message);
                    await messagesCollection.insertOne({
                        userId: userId,
                        message: `システム：緊急連絡先自動通知失敗 (LINE ID: ${emergencyContact})`,
                        replyText: `LINE ID (${emergencyContact}) への緊急通知に失敗しました。`,
                        respondedBy: 'こころちゃん（見守りcron）',
                        timestamp: new Date(),
                        logType: 'emergency_notification_failed_line_contact'
                    });
                }
            }
            // 緊急連絡先が電話番号の場合（SMS送信はLINE Messaging APIでは直接不可のため、ログに記録し、管理者に通知したことを再度伝える）
            else if (emergencyContact.match(/^0\d{9,10}$/)) {
                const manualNotificationMessage = `緊急連絡先（電話番号: ${emergencyContact}）へSMSでの自動通知はできません。管理者から直接連絡を試みてください。`;
                if (OWNER_USER_ID) {
                    await client.pushMessage(OWNER_USER_ID, { type: 'text', text: manualNotificationMessage });
                }
                console.log(`電話番号 (${emergencyContact}) への緊急通知はLINEからは直接できません。管理者へ通知済み。`);

                await messagesCollection.insertOne({
                    userId: userId,
                    message: `システム：緊急連絡先自動通知試行 (電話番号: ${emergencyContact} - 管理者へ通知済)`,
                    replyText: manualNotificationMessage,
                    respondedBy: 'こころちゃん（見守りcron）',
                    timestamp: new Date(),
                    logType: 'emergency_notification_to_phone_contact_request'
                });
                await usersCollection.updateOne(
                    { userId: userId },
                    { $set: { scheduledMessageSent: false, firstReminderSent: false, secondReminderSent: false } } // 通知後は状態をリセット
                );
            }
            // 緊急連絡先がメールアドレスの場合（メール送信はLINE Messaging APIでは直接不可のため、ログに記録し、管理者に通知したことを再度伝える）
            else if (emergencyContact.includes('@')) {
                const manualNotificationMessage = `緊急連絡先（メールアドレス: ${emergencyContact}）へメールでの自動通知はできません。管理者から直接連絡を試みてください。`;
                if (OWNER_USER_ID) {
                    await client.pushMessage(OWNER_USER_ID, { type: 'text', text: manualNotificationMessage });
                }
                console.log(`メールアドレス (${emergencyContact}) への緊急通知はLINEからは直接できません。管理者へ通知済み。`);

                await messagesCollection.insertOne({
                    userId: userId,
                    message: `システム：緊急連絡先自動通知試行 (メールアドレス: ${emergencyContact} - 管理者へ通知済)`,
                    replyText: manualNotificationMessage,
                    respondedBy: 'こころちゃん（見守りcron）',
                    timestamp: new Date(),
                    logType: 'emergency_notification_to_email_contact_request'
                });
                await usersCollection.updateOne(
                    { userId: userId },
                    { $set: { scheduledMessageSent: false, firstReminderSent: false, secondReminderSent: false } } // 通知後は状態をリセット
                );
            } else {
                console.error(`無効な緊急連絡先形式: ${emergencyContact} for user ${userId}`);
                await messagesCollection.insertOne({
                    userId: userId,
                    message: `システム：無効な緊急連絡先形式検出 (自動通知スキップ)`,
                    replyText: `ユーザー「${userDisplayName}」の緊急連絡先形式が不正なため、自動通知をスキップしました。`,
                    respondedBy: 'こころちゃん（見守りcron）',
                    timestamp: new Date(),
                    logType: 'emergency_notification_invalid_contact_format'
                });
            }
        }
    } catch (error) {
        console.error('緊急連絡先への通知チェック中にエラーが発生しました:', error);
    }
    console.log('--- 緊急連絡先への通知チェックを完了しました ---');
});
// LINEからのWebhookイベントハンドラ
app.post('/webhook', express.json(), async (req, res) => {
    const db = await connectToMongoDB();
    if (!db) {
        return res.status(500).send('Database not connected.');
    }
    const usersCollection = db.collection("users");
    const messagesCollection = db.collection("messages");

    Promise.all(req.body.events.map(async (event) => {
        // 重複イベントの処理 (LineBotWebhook/2.0 のUser-AgentでメッセージIDが同じものを破棄)
        if (event.type === 'message' && req.headers['user-agent'] === 'LineBotWebhook/2.0') {
            const messageId = event.message.id;
            const existingMessage = await messagesCollection.findOne({ messageId: messageId });
            if (existingMessage) {
                console.log(`重複メッセージを検出しました。スキップします。Message ID: ${messageId}`);
                return null; // 重複メッセージは処理しない
            }
            // 新しいメッセージIDをログに記録
            await messagesCollection.insertOne({
                messageId: messageId,
                userId: event.source.userId,
                timestamp: new Date(),
                logType: 'webhook_received',
                event: event // イベント全体を保存しておくとデバッグに便利
            });
        }

        if (event.type === 'message' && event.message.type === 'text') {
            const userId = event.source.userId;
            const userMessage = event.message.text;
            let replyText = 'ごめんなさい、うまく応答できませんでした。もう一度お話ししてください。'; // デフォルトの応答

            // ユーザー情報を取得または新規登録
            let user = await usersCollection.findOne({ userId: userId });
            if (!user) {
                user = {
                    userId: userId,
                    createdAt: new Date(),
                    flaggedMessageCount: 0,
                    isAccountSuspended: false,
                    isPermanentlyLocked: false,
                    wantsWatchCheck: false,
                    emergencyContact: null,
                    lastOkResponse: new Date(),
                    scheduledMessageSent: false,
                    firstReminderSent: false,
                    secondReminderSent: false,
                    membershipType: 'basic', // 新規ユーザーのデフォルト会員区分
                    isChildAI: false, // 新規ユーザーのisChildAIのデフォルト値
                    monthlyMessageCount: 0 // 新規ユーザーの月間メッセージカウント初期値
                };
                await usersCollection.insertOne(user);
                console.log(`新規ユーザーを登録しました: ${userId}`);
            }

            // メッセージカウントをインクリメント
            await usersCollection.updateOne(
                { userId: userId },
                { $inc: { monthlyMessageCount: 1 } }
            );
            console.log(`ユーザー ${userId} の月間メッセージカウント: ${user.monthlyMessageCount + 1}`);

            // 会員区分をチェックし、必要に応じて更新
            user.membershipType = await checkAndSetMembership(userId, usersCollection, messagesCollection);
            console.log(`ユーザー ${userId} の現在の会員区分: ${user.membershipType}`);

            // アカウント停止中のユーザー
            if (user.isAccountSuspended) {
                replyText = '現在、あなたのアカウントは停止されています。運営までお問い合わせください。';
                await client.replyMessage(event.replyToken, { type: 'text', text: replyText });
                await messagesCollection.insertOne({
                    userId: userId,
                    message: userMessage,
                    replyText: replyText,
                    respondedBy: 'こころちゃん（システム）',
                    timestamp: new Date(),
                    logType: 'account_suspended'
                });
                return; // 以降の処理をスキップ
            }

            // 永久ロック中のユーザー
            if (user.isPermanentlyLocked) {
                replyText = 'あなたのアカウントは永久にロックされています。このアカウントではAIと会話できません。';
                await client.replyMessage(event.replyToken, { type: 'text', text: replyText });
                await messagesCollection.insertOne({
                    userId: userId,
                    message: userMessage,
                    replyText: replyText,
                    respondedBy: 'こころちゃん（システム）',
                    timestamp: new Date(),
                    logType: 'account_permanently_locked'
                });
                return; // 以降の処理をスキップ
            }

            // 運営団体に関する質問の判定
            const isOrgQuestion = isOrganizationInquiry(userMessage);

            // 危険ワード、詐欺ワードの検出
            const detectedDangerWord = containsDangerWords(userMessage);
            const detectedScamWord = containsScamWords(userMessage);
            const detectedInappropriateWord = containsInappropriateWords(userMessage);

            // 緊急ワードが最優先で処理され、Gemini 1.5 Proで全力対応する仕組み
            if (detectedDangerWord) {
                console.log(`危険ワード検出（ユーザー: ${userId}）: ${userMessage}`);
                // 最上位モデルで即時対応（命優先のため、全制限無視）
                const emergencyResponse = await generateReply(userMessage, { membershipType: 'premium', isChildAI: user?.isChildAI || false });
                await client.replyMessage(event.replyToken, [
                    { type: 'text', text: emergencyResponse },
                    emergencyFlex // Flex Messageを追加
                ]);
                await messagesCollection.insertOne({
                    userId: userId,
                    message: userMessage,
                    replyText: emergencyResponse + " [緊急Flexメッセージ送信]",
                    respondedBy: 'こころちゃん（緊急対応）',
                    timestamp: new Date(),
                    logType: 'danger_word_detected'
                });

                // 管理者への通知
                if (OWNER_USER_ID) {
                    const userDisplayName = await getUserDisplayName(userId);
                    await client.pushMessage(OWNER_USER_ID, { type: 'text', text: `🚨緊急ワード検出🚨\nユーザー「${userDisplayName}」（ID: ${userId}）が危険な言葉を送信しました。\nメッセージ: 「${userMessage}」` });
                }
                return; // ここで処理を終了
            }

            // 詐欺ワードの検出
            if (detectedScamWord) {
                console.log(`詐欺ワード検出（ユーザー: ${userId}）: ${userMessage}`);
                const scamResponse = await generateReply(userMessage, { membershipType: 'premium', isChildAI: user?.isChildAI || false });
                await client.replyMessage(event.replyToken, [
                    { type: 'text', text: scamResponse },
                    scamFlex // Flex Messageを追加
                ]);
                await messagesCollection.insertOne({
                    userId: userId,
                    message: userMessage,
                    replyText: scamResponse + " [詐欺警告Flexメッセージ送信]",
                    respondedBy: 'こころちゃん（詐欺警告）',
                    timestamp: new Date(),
                    logType: 'scam_word_detected'
                });

                // 管理者への通知
                if (OWNER_USER_ID) {
                    const userDisplayName = await getUserDisplayName(userId);
                    await client.pushMessage(OWNER_USER_ID, { type: 'text', text: `⚠️詐欺ワード検出⚠️\nユーザー「${userDisplayName}」（ID: ${userId}）が詐欺の可能性のある言葉を送信しました。\nメッセージ: 「${userMessage}」` });
                }
                return; // ここで処理を終了
            }

            // 不適切ワードの検出
            if (detectedInappropriateWord) {
                console.log(`不適切ワード検出（ユーザー: ${userId}）: ${userMessage}`);
                replyText = 'ごめんなさい、その言葉は私には理解できません。別の言葉で話しかけてくれると嬉しいな😊';
                await client.replyMessage(event.replyToken, { type: 'text', text: replyText });
                await messagesCollection.insertOne({
                    userId: userId,
                    message: userMessage,
                    replyText: replyText,
                    respondedBy: 'こころちゃん（不適切ワード）',
                    timestamp: new Date(),
                    logType: 'inappropriate_word_detected'
                });

                // フラグ数を増やす
                await usersCollection.updateOne(
                    { userId: userId },
                    { $inc: { flaggedMessageCount: 1 } }
                );

                // フラグ数が5回を超えたらアカウント停止
                if (user.flaggedMessageCount + 1 >= 5) { // +1は現在のメッセージで増える分
                    await usersCollection.updateOne(
                        { userId: userId },
                        { $set: { isAccountSuspended: true, suspensionReason: '不適切な言葉の繰り返し使用' } }
                    );
                    const suspensionMessage = '続けて不適切な言葉を使用されたため、あなたのアカウントは一時的に停止されました。運営までお問い合わせください。';
                    await client.pushMessage(userId, { type: 'text', text: suspensionMessage });
                    await messagesCollection.insertOne({
                        userId: userId,
                        message: `システム：アカウント停止 (不適切ワード)`,
                        replyText: suspensionMessage,
                        respondedBy: 'こころちゃん（システム）',
                        timestamp: new Date(),
                        logType: 'account_suspended_by_inappropriate_words'
                    });

                    // 管理者への通知
                    if (OWNER_USER_ID) {
                        const userDisplayName = await getUserDisplayName(userId);
                        await client.pushMessage(OWNER_USER_ID, { type: 'text', text: `⚠️アカウント停止通知⚠️\nユーザー「${userDisplayName}」（ID: ${userId}）が不適切な言葉の繰り返し使用によりアカウント停止されました。` });
                    }
                }
                return; // ここで処理を終了
            }

            // 見守りサービスの登録・解除・OK応答を処理
            const handledByWatchService = await handleWatchServiceRegistration(event, usersCollection, messagesCollection, userId, userMessage);
            if (handledByWatchService) {
                return; // 見守りサービスで処理されたらここで終了
            }

            // 固定応答の確認
            const specialReply = checkSpecialReply(userMessage);
            if (specialReply) {
                replyText = specialReply;
                await client.replyMessage(event.replyToken, { type: 'text', text: replyText });
                // ログ記録
                await messagesCollection.insertOne({
                    userId: userId,
                    message: userMessage,
                    replyText: replyText,
                    respondedBy: 'こころちゃん（固定応答）',
                    timestamp: new Date(),
                    logType: 'special_reply'
                });
                return; // ここで処理を終了
            }

            // 運営団体に関する質問への応答
            if (isOrgQuestion) {
                replyText = 'このLINE Botは、特定非営利活動法人 介護支援事業所さくらによって運営されています。私たちは、高齢者支援や地域福祉活動を通じて、みんなが安心して暮らせる社会を目指しています🌸';
                await client.replyMessage(event.replyToken, { type: 'text', text: replyText });
                await messagesCollection.insertOne({
                    userId: userId,
                    message: userMessage,
                    replyText: replyText,
                    respondedBy: 'こころちゃん（組織情報）',
                    timestamp: new Date(),
                    logType: 'organization_inquiry'
                });
                return; // ここで処理を終了
            }

            // それ以外のメッセージはAIで応答
            if (user?.membershipType === 'limited' && user.monthlyMessageCount >= 50) { // 既に上限に達している場合はAI応答不可
                replyText = 'ごめんなさい、今月のAIとの会話回数が上限に達しました。来月1日に自動でリセットされますので、それまでお待ちくださいね。';
                await client.replyMessage(event.replyToken, { type: 'text', text: replyText });
                await messagesCollection.insertOne({
                    userId: userId,
                    message: userMessage,
                    replyText: replyText,
                    respondedBy: 'こころちゃん（制限）',
                    timestamp: new Date(),
                    logType: 'membership_limited_blocked'
                });
                return;
            }

            // AI応答生成
            // userオブジェクトを渡す前に、安全なプロパティアクセスを確認
            const aiReply = await generateReply(userMessage, user); // userオブジェクトをそのまま渡す
            replyText = aiReply;

            await client.replyMessage(event.replyToken, { type: 'text', text: replyText });

            // AI応答をログに記録
            await messagesCollection.insertOne({
                userId: userId,
                message: userMessage,
                replyText: replyText,
                respondedBy: 'こころちゃん（AI）',
                timestamp: new Date(),
                logType: 'ai_response'
            });

        } else if (event.type === 'follow') {
            const userId = event.source.userId;
            let user = await usersCollection.findOne({ userId: userId });
            if (!user) {
                user = {
                    userId: userId,
                    createdAt: new Date(),
                    flaggedMessageCount: 0,
                    isAccountSuspended: false,
                    isPermanentlyLocked: false,
                    wantsWatchCheck: false,
                    emergencyContact: null,
                    lastOkResponse: new Date(),
                    scheduledMessageSent: false,
                    firstReminderSent: false,
                    secondReminderSent: false,
                    membershipType: 'basic', // 新規ユーザーのデフォルト会員区分
                    isChildAI: false, // 新規ユーザーのisChildAIのデフォルト値
                    monthlyMessageCount: 0 // 新規ユーザーの月間メッセージカウント初期値
                };
                await usersCollection.insertOne(user);
                console.log(`新規ユーザーを登録しました: ${userId}`);
            }

            const welcomeMessage = `はじめまして、まつさん！こころちゃんです😊\n\n私はあなたの心に寄り添い、お話を聞いたり、見守りサービスを提供したりできます。\n\n何か困ったことや話したいことがあったら、いつでも声をかけてくださいね💖\n\n「見守り登録します」とメッセージを送ると、見守りサービスの説明と登録ができますよ🌸`;
            await client.replyMessage(event.replyToken, { type: 'text', text: welcomeMessage });
            await messagesCollection.insertOne({
                userId: userId,
                message: 'システム：フォローイベント',
                replyText: welcomeMessage,
                respondedBy: 'こころちゃん（システム）',
                timestamp: new Date(),
                logType: 'follow_event'
            });
        }
    })).catch((err) => {
        console.error('個別イベント処理中にエラーが発生しました:', err);
        // エラー発生時もLINEに200 OKを返すことで、LINEの再送を防ぐ
    });
    res.sendStatus(200); // LINEに成功を通知
});

// エラーハンドリングミドルウェア
app.use((err, req, res, next) => {
    console.error(err.stack);
    res.status(500).send('Something broke!');
});

// サーバー起動
const port = process.env.PORT || 3000;
app.listen(port, async () => {
    console.log(`サーバーがポート ${port} で起動しました。`);
    await connectToMongoDB(); // サーバー起動時にMongoDBに接続
});
